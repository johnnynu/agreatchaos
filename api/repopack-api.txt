================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-09-06T01:15:27.928Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
bootstrap
cmd/lambda/complete_upload/main.go
cmd/lambda/create_file/main.go
cmd/lambda/delete_file/main.go
cmd/lambda/generate_download_url/main.go
cmd/lambda/generate_upload_url/main.go
cmd/lambda/handle_upload/main.go
cmd/lambda/list_files/main.go
cmd/lambda/preview_file/main.go
cmd/lambda/signin_user/main.go
cmd/lambda/stream/main.go
complete_upload.zip
create_file.zip
delete_file.zip
generate_download_url.zip
generate_upload_url.zip
go.mod
go.sum
handle_upload.zip
internal/db/dynamodb.go
internal/handlers/complete_upload.go
internal/handlers/create_file.go
internal/handlers/dbstream.go
internal/handlers/delete_file.go
internal/handlers/generate_download_url.go
internal/handlers/generate_upload_url.go
internal/handlers/list_files.go
internal/handlers/preview_file.go
internal/handlers/process_upload.go
internal/handlers/signin_user.go
list_files.zip
pkg/utils/response.go
preview_file.zip
repopack-api.txt
signin_user.zip

================================================================
Repository Files
================================================================

================
File: go.mod
================
module github.com/johnnynu/agreatchaos/api

go 1.22.3

require github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue v1.15.0

require (
	github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.4 // indirect
	github.com/aws/aws-sdk-go-v2/internal/v4a v1.3.16 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.3.18 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.17.16 // indirect
)

require (
	github.com/aws/aws-lambda-go v1.47.0 // indirect
	github.com/aws/aws-sdk-go-v2 v1.30.4 // indirect
	github.com/aws/aws-sdk-go-v2/config v1.27.27 // indirect
	github.com/aws/aws-sdk-go-v2/credentials v1.17.27 // indirect
	github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression v1.7.35
	github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.16.11 // indirect
	github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.16 // indirect
	github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.16 // indirect
	github.com/aws/aws-sdk-go-v2/internal/ini v1.8.0 // indirect
	github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider v1.43.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/dynamodb v1.34.6 // indirect
	github.com/aws/aws-sdk-go-v2/service/dynamodbstreams v1.22.5 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.4 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/endpoint-discovery v1.9.17 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.18 // indirect
	github.com/aws/aws-sdk-go-v2/service/s3 v1.60.1
	github.com/aws/aws-sdk-go-v2/service/sso v1.22.4 // indirect
	github.com/aws/aws-sdk-go-v2/service/ssooidc v1.26.4 // indirect
	github.com/aws/aws-sdk-go-v2/service/sts v1.30.3 // indirect
	github.com/aws/smithy-go v1.20.4 // indirect
	github.com/google/uuid v1.6.0
	github.com/jmespath/go-jmespath v0.4.0 // indirect
)

================
File: go.sum
================
github.com/aws/aws-lambda-go v1.47.0 h1:0H8s0vumYx/YKs4sE7YM0ktwL2eWse+kfopsRI1sXVI=
github.com/aws/aws-lambda-go v1.47.0/go.mod h1:dpMpZgvWx5vuQJfBt0zqBha60q7Dd7RfgJv23DymV8A=
github.com/aws/aws-sdk-go-v2 v1.30.3 h1:jUeBtG0Ih+ZIFH0F4UkmL9w3cSpaMv9tYYDbzILP8dY=
github.com/aws/aws-sdk-go-v2 v1.30.3/go.mod h1:nIQjQVp5sfpQcTc9mPSr1B0PaWK5ByX9MOoDadSN4lc=
github.com/aws/aws-sdk-go-v2 v1.30.4 h1:frhcagrVNrzmT95RJImMHgabt99vkXGslubDaDagTk8=
github.com/aws/aws-sdk-go-v2 v1.30.4/go.mod h1:CT+ZPWXbYrci8chcARI3OmI/qgd+f6WtuLOoaIA8PR0=
github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.4 h1:70PVAiL15/aBMh5LThwgXdSQorVr91L127ttckI9QQU=
github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.4/go.mod h1:/MQxMqci8tlqDH+pjmoLu1i0tbWCUP1hhyMRuFxpQCw=
github.com/aws/aws-sdk-go-v2/config v1.27.27 h1:HdqgGt1OAP0HkEDDShEl0oSYa9ZZBSOmKpdpsDMdO90=
github.com/aws/aws-sdk-go-v2/config v1.27.27/go.mod h1:MVYamCg76dFNINkZFu4n4RjDixhVr51HLj4ErWzrVwg=
github.com/aws/aws-sdk-go-v2/credentials v1.17.27 h1:2raNba6gr2IfA0eqqiP2XiQ0UVOpGPgDSi0I9iAP+UI=
github.com/aws/aws-sdk-go-v2/credentials v1.17.27/go.mod h1:gniiwbGahQByxan6YjQUMcW4Aov6bLC3m+evgcoN4r4=
github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue v1.14.10 h1:orAIBscNu5aIjDOnKIrjO+IUFPMLKj3Lp0bPf4chiPc=
github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue v1.14.10/go.mod h1:GNjJ8daGhv10hmQYCnmkV8HuY6xXOXV4vzBssSjEIlU=
github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue v1.15.0 h1:zExbglw6JfQeXPLHmWg6vxOXdkvuZkEKRVo69scPd4M=
github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue v1.15.0/go.mod h1:bswOrGH35stnF9k41t5gKQ8b+j6B4SLe6cF3xHuJG6E=
github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression v1.7.35 h1:KX0BhLub8MxdzV9Le8o5FbVe9uIdupRpQNpWihYqOCo=
github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression v1.7.35/go.mod h1:AU11ceCYiyPIZqR6XCoPrFS02h8XwqC8Yfa+ZnE+OkA=
github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.16.11 h1:KreluoV8FZDEtI6Co2xuNk/UqI9iwMrOx/87PBNIKqw=
github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.16.11/go.mod h1:SeSUYBLsMYFoRvHE0Tjvn7kbxaUhl75CJi1sbfhMxkU=
github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.15 h1:SoNJ4RlFEQEbtDcCEt+QG56MY4fm4W8rYirAmq+/DdU=
github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.15/go.mod h1:U9ke74k1n2bf+RIgoX1SXFed1HLs51OgUSs+Ph0KJP8=
github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.16 h1:TNyt/+X43KJ9IJJMjKfa3bNTiZbUP7DeCxfbTROESwY=
github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.16/go.mod h1:2DwJF39FlNAUiX5pAc0UNeiz16lK2t7IaFcm0LFHEgc=
github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.15 h1:C6WHdGnTDIYETAm5iErQUiVNsclNx9qbJVPIt03B6bI=
github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.15/go.mod h1:ZQLZqhcu+JhSrA9/NXRm8SkDvsycE+JkV3WGY41e+IM=
github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.16 h1:jYfy8UPmd+6kJW5YhY0L1/KftReOGxI/4NtVSTh9O/I=
github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.16/go.mod h1:7ZfEPZxkW42Afq4uQB8H2E2e6ebh6mXTueEpYzjCzcs=
github.com/aws/aws-sdk-go-v2/internal/ini v1.8.0 h1:hT8rVHwugYE2lEfdFE0QWVo81lF7jMrYJVDWI+f+VxU=
github.com/aws/aws-sdk-go-v2/internal/ini v1.8.0/go.mod h1:8tu/lYfQfFe6IGnaOdrpVgEL2IrrDOf6/m9RQum4NkY=
github.com/aws/aws-sdk-go-v2/internal/v4a v1.3.16 h1:mimdLQkIX1zr8GIPY1ZtALdBQGxcASiBd2MOp8m/dMc=
github.com/aws/aws-sdk-go-v2/internal/v4a v1.3.16/go.mod h1:YHk6owoSwrIsok+cAH9PENCOGoH5PU2EllX4vLtSrsY=
github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider v1.43.1 h1:sUmqM7zfIHud8iY+fTGcnJXZIVLVcepUv0Vflvmya58=
github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider v1.43.1/go.mod h1:aynIysFCBIq18wfN2GrIYAeofOnQKV3LtkjyrQKfaFY=
github.com/aws/aws-sdk-go-v2/service/dynamodb v1.34.4 h1:utG3S4T+X7nONPIpRoi1tVcQdAdJxntiVS2yolPJyXc=
github.com/aws/aws-sdk-go-v2/service/dynamodb v1.34.4/go.mod h1:q9vzW3Xr1KEXa8n4waHiFt1PrppNDlMymlYP+xpsFbY=
github.com/aws/aws-sdk-go-v2/service/dynamodb v1.34.6 h1:LKZuRTlh8RszjuWcUwEDvCGwjx5olHPp6ZOepyZV5p8=
github.com/aws/aws-sdk-go-v2/service/dynamodb v1.34.6/go.mod h1:s2fYaueBuCnwv1XQn6T8TfShxJWusv5tWPMcL+GY6+g=
github.com/aws/aws-sdk-go-v2/service/dynamodbstreams v1.22.3 h1:r27/FnxLPixKBRIlslsvhqscBuMK8uysCYG9Kfgm098=
github.com/aws/aws-sdk-go-v2/service/dynamodbstreams v1.22.3/go.mod h1:jqOFyN+QSWSoQC+ppyc4weiO8iNQXbzRbxDjQ1ayYd4=
github.com/aws/aws-sdk-go-v2/service/dynamodbstreams v1.22.5 h1:sM/SaWUKPtsCcXE0bHZPUG4jjCbFbxakyptXQbYLrdU=
github.com/aws/aws-sdk-go-v2/service/dynamodbstreams v1.22.5/go.mod h1:3YxVsEoCNYOLIbdA+cCXSp1fom9hrhyB1DsCiYryCaQ=
github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.3 h1:dT3MqvGhSoaIhRseqw2I0yH81l7wiR2vjs57O51EAm8=
github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.3/go.mod h1:GlAeCkHwugxdHaueRr4nhPuY+WW+gR8UjlcqzPr1SPI=
github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.4 h1:KypMCbLPPHEmf9DgMGw51jMj77VfGPAN2Kv4cfhlfgI=
github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.4/go.mod h1:Vz1JQXliGcQktFTN/LN6uGppAIRoLBR2bMvIMP0gOjc=
github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.3.18 h1:GckUnpm4EJOAio1c8o25a+b3lVfwVzC9gnSBqiiNmZM=
github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.3.18/go.mod h1:Br6+bxfG33Dk3ynmkhsW2Z/t9D4+lRqdLDNCKi85w0U=
github.com/aws/aws-sdk-go-v2/service/internal/endpoint-discovery v1.9.16 h1:lhAX5f7KpgwyieXjbDnRTjPEUI0l3emSRyxXj1PXP8w=
github.com/aws/aws-sdk-go-v2/service/internal/endpoint-discovery v1.9.16/go.mod h1:AblAlCwvi7Q/SFowvckgN+8M3uFPlopSYeLlbNDArhA=
github.com/aws/aws-sdk-go-v2/service/internal/endpoint-discovery v1.9.17 h1:HDJGz1jlV7RokVgTPfx1UHBHANC0N5Uk++xgyYgz5E0=
github.com/aws/aws-sdk-go-v2/service/internal/endpoint-discovery v1.9.17/go.mod h1:5szDu6TWdRDytfDxUQVv2OYfpTQMKApVFyqpm+TcA98=
github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.17 h1:HGErhhrxZlQ044RiM+WdoZxp0p+EGM62y3L6pwA4olE=
github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.17/go.mod h1:RkZEx4l0EHYDJpWppMJ3nD9wZJAa8/0lq9aVC+r2UII=
github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.18 h1:tJ5RnkHCiSH0jyd6gROjlJtNwov0eGYNz8s8nFcR0jQ=
github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.18/go.mod h1:++NHzT+nAF7ZPrHPsA+ENvsXkOO8wEu+C6RXltAG4/c=
github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.17.16 h1:jg16PhLPUiHIj8zYIW6bqzeQSuHVEiWnGA0Brz5Xv2I=
github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.17.16/go.mod h1:Uyk1zE1VVdsHSU7096h/rwnXDzOzYQVl+FNPhPw7ShY=
github.com/aws/aws-sdk-go-v2/service/s3 v1.60.1 h1:mx2ucgtv+MWzJesJY9Ig/8AFHgoE5FwLXwUVgW/FGdI=
github.com/aws/aws-sdk-go-v2/service/s3 v1.60.1/go.mod h1:BSPI0EfnYUuNHPS0uqIo5VrRwzie+Fp+YhQOUs16sKI=
github.com/aws/aws-sdk-go-v2/service/sso v1.22.4 h1:BXx0ZIxvrJdSgSvKTZ+yRBeSqqgPM89VPlulEcl37tM=
github.com/aws/aws-sdk-go-v2/service/sso v1.22.4/go.mod h1:ooyCOXjvJEsUw7x+ZDHeISPMhtwI3ZCB7ggFMcFfWLU=
github.com/aws/aws-sdk-go-v2/service/ssooidc v1.26.4 h1:yiwVzJW2ZxZTurVbYWA7QOrAaCYQR72t0wrSBfoesUE=
github.com/aws/aws-sdk-go-v2/service/ssooidc v1.26.4/go.mod h1:0oxfLkpz3rQ/CHlx5hB7H69YUpFiI1tql6Q6Ne+1bCw=
github.com/aws/aws-sdk-go-v2/service/sts v1.30.3 h1:ZsDKRLXGWHk8WdtyYMoGNO7bTudrvuKpDKgMVRlepGE=
github.com/aws/aws-sdk-go-v2/service/sts v1.30.3/go.mod h1:zwySh8fpFyXp9yOr/KVzxOl8SRqgf/IDw5aUt9UKFcQ=
github.com/aws/smithy-go v1.20.3 h1:ryHwveWzPV5BIof6fyDvor6V3iUL7nTfiTKXHiW05nE=
github.com/aws/smithy-go v1.20.3/go.mod h1:krry+ya/rV9RDcV/Q16kpu6ypI4K2czasz0NC3qS14E=
github.com/aws/smithy-go v1.20.4 h1:2HK1zBdPgRbjFOHlfeQZfpC4r72MOb9bZkiFwggKO+4=
github.com/aws/smithy-go v1.20.4/go.mod h1:irrKGvNn1InZwb2d7fkIRNucdfwR8R+Ts3wxYa/cJHg=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/jmespath/go-jmespath v0.4.0 h1:BEgLn5cpjn8UN1mAw4NjwDrS35OdebyEtFe+9YPoQUg=
github.com/jmespath/go-jmespath v0.4.0/go.mod h1:T8mJZnbsbmF+m6zOOFylbeCJqk5+pHWvzYPziyZiYoo=
github.com/jmespath/go-jmespath/internal/testify v1.5.1/go.mod h1:L3OGu8Wl2/fWfCI6z80xFu9LTZmf1ZRjMHUOPmWr69U=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=

================
File: repopack-api.txt
================
================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-09-02T04:41:47.558Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
bootstrap
cmd/lambda/create_file/main.go
cmd/lambda/delete_file/main.go
cmd/lambda/generate_download_url/main.go
cmd/lambda/generate_upload_url/main.go
cmd/lambda/handle_upload/main.go
cmd/lambda/list_files/main.go
cmd/lambda/preview_file/main.go
cmd/lambda/signin_user/main.go
cmd/lambda/stream/main.go
create_file.zip
delete_file.zip
generate_download_url.zip
generate_upload_url.zip
go.mod
go.sum
handle_upload.zip
internal/db/dynamodb.go
internal/handlers/create_file.go
internal/handlers/dbstream.go
internal/handlers/delete_file.go
internal/handlers/generate_download_url.go
internal/handlers/generate_upload_url.go
internal/handlers/list_files.go
internal/handlers/preview_file.go
internal/handlers/process_upload.go
internal/handlers/signin_user.go
list_files.zip
pkg/utils/response.go
preview_file.zip
repopack-api.txt
signin_user.zip

================================================================
Repository Files
================================================================

================
File: go.mod
================
module github.com/johnnynu/agreatchaos/api

go 1.22.3

require github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue v1.15.0

require (
	github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.4 // indirect
	github.com/aws/aws-sdk-go-v2/internal/v4a v1.3.16 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.3.18 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.17.16 // indirect
)

require (
	github.com/aws/aws-lambda-go v1.47.0 // indirect
	github.com/aws/aws-sdk-go-v2 v1.30.4 // indirect
	github.com/aws/aws-sdk-go-v2/config v1.27.27 // indirect
	github.com/aws/aws-sdk-go-v2/credentials v1.17.27 // indirect
	github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression v1.7.35
	github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.16.11 // indirect
	github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.16 // indirect
	github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.16 // indirect
	github.com/aws/aws-sdk-go-v2/internal/ini v1.8.0 // indirect
	github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider v1.43.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/dynamodb v1.34.6 // indirect
	github.com/aws/aws-sdk-go-v2/service/dynamodbstreams v1.22.5 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.4 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/endpoint-discovery v1.9.17 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.18 // indirect
	github.com/aws/aws-sdk-go-v2/service/s3 v1.60.1
	github.com/aws/aws-sdk-go-v2/service/sso v1.22.4 // indirect
	github.com/aws/aws-sdk-go-v2/service/ssooidc v1.26.4 // indirect
	github.com/aws/aws-sdk-go-v2/service/sts v1.30.3 // indirect
	github.com/aws/smithy-go v1.20.4 // indirect
	github.com/google/uuid v1.6.0
	github.com/jmespath/go-jmespath v0.4.0 // indirect
)

================
File: go.sum
================
github.com/aws/aws-lambda-go v1.47.0 h1:0H8s0vumYx/YKs4sE7YM0ktwL2eWse+kfopsRI1sXVI=
github.com/aws/aws-lambda-go v1.47.0/go.mod h1:dpMpZgvWx5vuQJfBt0zqBha60q7Dd7RfgJv23DymV8A=
github.com/aws/aws-sdk-go-v2 v1.30.3 h1:jUeBtG0Ih+ZIFH0F4UkmL9w3cSpaMv9tYYDbzILP8dY=
github.com/aws/aws-sdk-go-v2 v1.30.3/go.mod h1:nIQjQVp5sfpQcTc9mPSr1B0PaWK5ByX9MOoDadSN4lc=
github.com/aws/aws-sdk-go-v2 v1.30.4 h1:frhcagrVNrzmT95RJImMHgabt99vkXGslubDaDagTk8=
github.com/aws/aws-sdk-go-v2 v1.30.4/go.mod h1:CT+ZPWXbYrci8chcARI3OmI/qgd+f6WtuLOoaIA8PR0=
github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.4 h1:70PVAiL15/aBMh5LThwgXdSQorVr91L127ttckI9QQU=
github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.4/go.mod h1:/MQxMqci8tlqDH+pjmoLu1i0tbWCUP1hhyMRuFxpQCw=
github.com/aws/aws-sdk-go-v2/config v1.27.27 h1:HdqgGt1OAP0HkEDDShEl0oSYa9ZZBSOmKpdpsDMdO90=
github.com/aws/aws-sdk-go-v2/config v1.27.27/go.mod h1:MVYamCg76dFNINkZFu4n4RjDixhVr51HLj4ErWzrVwg=
github.com/aws/aws-sdk-go-v2/credentials v1.17.27 h1:2raNba6gr2IfA0eqqiP2XiQ0UVOpGPgDSi0I9iAP+UI=
github.com/aws/aws-sdk-go-v2/credentials v1.17.27/go.mod h1:gniiwbGahQByxan6YjQUMcW4Aov6bLC3m+evgcoN4r4=
github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue v1.14.10 h1:orAIBscNu5aIjDOnKIrjO+IUFPMLKj3Lp0bPf4chiPc=
github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue v1.14.10/go.mod h1:GNjJ8daGhv10hmQYCnmkV8HuY6xXOXV4vzBssSjEIlU=
github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue v1.15.0 h1:zExbglw6JfQeXPLHmWg6vxOXdkvuZkEKRVo69scPd4M=
github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue v1.15.0/go.mod h1:bswOrGH35stnF9k41t5gKQ8b+j6B4SLe6cF3xHuJG6E=
github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression v1.7.35 h1:KX0BhLub8MxdzV9Le8o5FbVe9uIdupRpQNpWihYqOCo=
github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression v1.7.35/go.mod h1:AU11ceCYiyPIZqR6XCoPrFS02h8XwqC8Yfa+ZnE+OkA=
github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.16.11 h1:KreluoV8FZDEtI6Co2xuNk/UqI9iwMrOx/87PBNIKqw=
github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.16.11/go.mod h1:SeSUYBLsMYFoRvHE0Tjvn7kbxaUhl75CJi1sbfhMxkU=
github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.15 h1:SoNJ4RlFEQEbtDcCEt+QG56MY4fm4W8rYirAmq+/DdU=
github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.15/go.mod h1:U9ke74k1n2bf+RIgoX1SXFed1HLs51OgUSs+Ph0KJP8=
github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.16 h1:TNyt/+X43KJ9IJJMjKfa3bNTiZbUP7DeCxfbTROESwY=
github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.16/go.mod h1:2DwJF39FlNAUiX5pAc0UNeiz16lK2t7IaFcm0LFHEgc=
github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.15 h1:C6WHdGnTDIYETAm5iErQUiVNsclNx9qbJVPIt03B6bI=
github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.15/go.mod h1:ZQLZqhcu+JhSrA9/NXRm8SkDvsycE+JkV3WGY41e+IM=
github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.16 h1:jYfy8UPmd+6kJW5YhY0L1/KftReOGxI/4NtVSTh9O/I=
github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.16/go.mod h1:7ZfEPZxkW42Afq4uQB8H2E2e6ebh6mXTueEpYzjCzcs=
github.com/aws/aws-sdk-go-v2/internal/ini v1.8.0 h1:hT8rVHwugYE2lEfdFE0QWVo81lF7jMrYJVDWI+f+VxU=
github.com/aws/aws-sdk-go-v2/internal/ini v1.8.0/go.mod h1:8tu/lYfQfFe6IGnaOdrpVgEL2IrrDOf6/m9RQum4NkY=
github.com/aws/aws-sdk-go-v2/internal/v4a v1.3.16 h1:mimdLQkIX1zr8GIPY1ZtALdBQGxcASiBd2MOp8m/dMc=
github.com/aws/aws-sdk-go-v2/internal/v4a v1.3.16/go.mod h1:YHk6owoSwrIsok+cAH9PENCOGoH5PU2EllX4vLtSrsY=
github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider v1.43.1 h1:sUmqM7zfIHud8iY+fTGcnJXZIVLVcepUv0Vflvmya58=
github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider v1.43.1/go.mod h1:aynIysFCBIq18wfN2GrIYAeofOnQKV3LtkjyrQKfaFY=
github.com/aws/aws-sdk-go-v2/service/dynamodb v1.34.4 h1:utG3S4T+X7nONPIpRoi1tVcQdAdJxntiVS2yolPJyXc=
github.com/aws/aws-sdk-go-v2/service/dynamodb v1.34.4/go.mod h1:q9vzW3Xr1KEXa8n4waHiFt1PrppNDlMymlYP+xpsFbY=
github.com/aws/aws-sdk-go-v2/service/dynamodb v1.34.6 h1:LKZuRTlh8RszjuWcUwEDvCGwjx5olHPp6ZOepyZV5p8=
github.com/aws/aws-sdk-go-v2/service/dynamodb v1.34.6/go.mod h1:s2fYaueBuCnwv1XQn6T8TfShxJWusv5tWPMcL+GY6+g=
github.com/aws/aws-sdk-go-v2/service/dynamodbstreams v1.22.3 h1:r27/FnxLPixKBRIlslsvhqscBuMK8uysCYG9Kfgm098=
github.com/aws/aws-sdk-go-v2/service/dynamodbstreams v1.22.3/go.mod h1:jqOFyN+QSWSoQC+ppyc4weiO8iNQXbzRbxDjQ1ayYd4=
github.com/aws/aws-sdk-go-v2/service/dynamodbstreams v1.22.5 h1:sM/SaWUKPtsCcXE0bHZPUG4jjCbFbxakyptXQbYLrdU=
github.com/aws/aws-sdk-go-v2/service/dynamodbstreams v1.22.5/go.mod h1:3YxVsEoCNYOLIbdA+cCXSp1fom9hrhyB1DsCiYryCaQ=
github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.3 h1:dT3MqvGhSoaIhRseqw2I0yH81l7wiR2vjs57O51EAm8=
github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.3/go.mod h1:GlAeCkHwugxdHaueRr4nhPuY+WW+gR8UjlcqzPr1SPI=
github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.4 h1:KypMCbLPPHEmf9DgMGw51jMj77VfGPAN2Kv4cfhlfgI=
github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.4/go.mod h1:Vz1JQXliGcQktFTN/LN6uGppAIRoLBR2bMvIMP0gOjc=
github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.3.18 h1:GckUnpm4EJOAio1c8o25a+b3lVfwVzC9gnSBqiiNmZM=
github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.3.18/go.mod h1:Br6+bxfG33Dk3ynmkhsW2Z/t9D4+lRqdLDNCKi85w0U=
github.com/aws/aws-sdk-go-v2/service/internal/endpoint-discovery v1.9.16 h1:lhAX5f7KpgwyieXjbDnRTjPEUI0l3emSRyxXj1PXP8w=
github.com/aws/aws-sdk-go-v2/service/internal/endpoint-discovery v1.9.16/go.mod h1:AblAlCwvi7Q/SFowvckgN+8M3uFPlopSYeLlbNDArhA=
github.com/aws/aws-sdk-go-v2/service/internal/endpoint-discovery v1.9.17 h1:HDJGz1jlV7RokVgTPfx1UHBHANC0N5Uk++xgyYgz5E0=
github.com/aws/aws-sdk-go-v2/service/internal/endpoint-discovery v1.9.17/go.mod h1:5szDu6TWdRDytfDxUQVv2OYfpTQMKApVFyqpm+TcA98=
github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.17 h1:HGErhhrxZlQ044RiM+WdoZxp0p+EGM62y3L6pwA4olE=
github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.17/go.mod h1:RkZEx4l0EHYDJpWppMJ3nD9wZJAa8/0lq9aVC+r2UII=
github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.18 h1:tJ5RnkHCiSH0jyd6gROjlJtNwov0eGYNz8s8nFcR0jQ=
github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.18/go.mod h1:++NHzT+nAF7ZPrHPsA+ENvsXkOO8wEu+C6RXltAG4/c=
github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.17.16 h1:jg16PhLPUiHIj8zYIW6bqzeQSuHVEiWnGA0Brz5Xv2I=
github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.17.16/go.mod h1:Uyk1zE1VVdsHSU7096h/rwnXDzOzYQVl+FNPhPw7ShY=
github.com/aws/aws-sdk-go-v2/service/s3 v1.60.1 h1:mx2ucgtv+MWzJesJY9Ig/8AFHgoE5FwLXwUVgW/FGdI=
github.com/aws/aws-sdk-go-v2/service/s3 v1.60.1/go.mod h1:BSPI0EfnYUuNHPS0uqIo5VrRwzie+Fp+YhQOUs16sKI=
github.com/aws/aws-sdk-go-v2/service/sso v1.22.4 h1:BXx0ZIxvrJdSgSvKTZ+yRBeSqqgPM89VPlulEcl37tM=
github.com/aws/aws-sdk-go-v2/service/sso v1.22.4/go.mod h1:ooyCOXjvJEsUw7x+ZDHeISPMhtwI3ZCB7ggFMcFfWLU=
github.com/aws/aws-sdk-go-v2/service/ssooidc v1.26.4 h1:yiwVzJW2ZxZTurVbYWA7QOrAaCYQR72t0wrSBfoesUE=
github.com/aws/aws-sdk-go-v2/service/ssooidc v1.26.4/go.mod h1:0oxfLkpz3rQ/CHlx5hB7H69YUpFiI1tql6Q6Ne+1bCw=
github.com/aws/aws-sdk-go-v2/service/sts v1.30.3 h1:ZsDKRLXGWHk8WdtyYMoGNO7bTudrvuKpDKgMVRlepGE=
github.com/aws/aws-sdk-go-v2/service/sts v1.30.3/go.mod h1:zwySh8fpFyXp9yOr/KVzxOl8SRqgf/IDw5aUt9UKFcQ=
github.com/aws/smithy-go v1.20.3 h1:ryHwveWzPV5BIof6fyDvor6V3iUL7nTfiTKXHiW05nE=
github.com/aws/smithy-go v1.20.3/go.mod h1:krry+ya/rV9RDcV/Q16kpu6ypI4K2czasz0NC3qS14E=
github.com/aws/smithy-go v1.20.4 h1:2HK1zBdPgRbjFOHlfeQZfpC4r72MOb9bZkiFwggKO+4=
github.com/aws/smithy-go v1.20.4/go.mod h1:irrKGvNn1InZwb2d7fkIRNucdfwR8R+Ts3wxYa/cJHg=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/jmespath/go-jmespath v0.4.0 h1:BEgLn5cpjn8UN1mAw4NjwDrS35OdebyEtFe+9YPoQUg=
github.com/jmespath/go-jmespath v0.4.0/go.mod h1:T8mJZnbsbmF+m6zOOFylbeCJqk5+pHWvzYPziyZiYoo=
github.com/jmespath/go-jmespath/internal/testify v1.5.1/go.mod h1:L3OGu8Wl2/fWfCI6z80xFu9LTZmf1ZRjMHUOPmWr69U=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=

================
File: repopack-api.txt
================
================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-08-27T01:21:12.965Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
bootstrap
cmd/lambda/create_file/main.go
cmd/lambda/delete_file/main.go
cmd/lambda/generate_download_url/main.go
cmd/lambda/generate_upload_url/main.go
cmd/lambda/handle_upload/main.go
cmd/lambda/list_files/main.go
cmd/lambda/preview_file/main.go
cmd/lambda/signin_user/main.go
cmd/lambda/stream/main.go
create_file.zip
delete_file.zip
generate_download_url.zip
generate_upload_url.zip
go.mod
go.sum
handle_upload.zip
internal/db/dynamodb.go
internal/handlers/create_file.go
internal/handlers/dbstream.go
internal/handlers/delete_file.go
internal/handlers/generate_download_url.go
internal/handlers/generate_upload_url.go
internal/handlers/list_files.go
internal/handlers/preview_file.go
internal/handlers/process_upload.go
internal/handlers/signin_user.go
list_files.zip
pkg/utils/response.go
preview_file.zip
signin_user.zip

================================================================
Repository Files
================================================================

================
File: go.mod
================
module github.com/johnnynu/agreatchaos/api

go 1.22.3

require github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue v1.15.0

require (
	github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.4 // indirect
	github.com/aws/aws-sdk-go-v2/internal/v4a v1.3.16 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.3.18 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.17.16 // indirect
)

require (
	github.com/aws/aws-lambda-go v1.47.0 // indirect
	github.com/aws/aws-sdk-go-v2 v1.30.4 // indirect
	github.com/aws/aws-sdk-go-v2/config v1.27.27 // indirect
	github.com/aws/aws-sdk-go-v2/credentials v1.17.27 // indirect
	github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression v1.7.35
	github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.16.11 // indirect
	github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.16 // indirect
	github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.16 // indirect
	github.com/aws/aws-sdk-go-v2/internal/ini v1.8.0 // indirect
	github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider v1.43.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/dynamodb v1.34.6 // indirect
	github.com/aws/aws-sdk-go-v2/service/dynamodbstreams v1.22.5 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.4 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/endpoint-discovery v1.9.17 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.18 // indirect
	github.com/aws/aws-sdk-go-v2/service/s3 v1.60.1
	github.com/aws/aws-sdk-go-v2/service/sso v1.22.4 // indirect
	github.com/aws/aws-sdk-go-v2/service/ssooidc v1.26.4 // indirect
	github.com/aws/aws-sdk-go-v2/service/sts v1.30.3 // indirect
	github.com/aws/smithy-go v1.20.4 // indirect
	github.com/google/uuid v1.6.0
	github.com/jmespath/go-jmespath v0.4.0 // indirect
)

================
File: go.sum
================
github.com/aws/aws-lambda-go v1.47.0 h1:0H8s0vumYx/YKs4sE7YM0ktwL2eWse+kfopsRI1sXVI=
github.com/aws/aws-lambda-go v1.47.0/go.mod h1:dpMpZgvWx5vuQJfBt0zqBha60q7Dd7RfgJv23DymV8A=
github.com/aws/aws-sdk-go-v2 v1.30.3 h1:jUeBtG0Ih+ZIFH0F4UkmL9w3cSpaMv9tYYDbzILP8dY=
github.com/aws/aws-sdk-go-v2 v1.30.3/go.mod h1:nIQjQVp5sfpQcTc9mPSr1B0PaWK5ByX9MOoDadSN4lc=
github.com/aws/aws-sdk-go-v2 v1.30.4 h1:frhcagrVNrzmT95RJImMHgabt99vkXGslubDaDagTk8=
github.com/aws/aws-sdk-go-v2 v1.30.4/go.mod h1:CT+ZPWXbYrci8chcARI3OmI/qgd+f6WtuLOoaIA8PR0=
github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.4 h1:70PVAiL15/aBMh5LThwgXdSQorVr91L127ttckI9QQU=
github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.4/go.mod h1:/MQxMqci8tlqDH+pjmoLu1i0tbWCUP1hhyMRuFxpQCw=
github.com/aws/aws-sdk-go-v2/config v1.27.27 h1:HdqgGt1OAP0HkEDDShEl0oSYa9ZZBSOmKpdpsDMdO90=
github.com/aws/aws-sdk-go-v2/config v1.27.27/go.mod h1:MVYamCg76dFNINkZFu4n4RjDixhVr51HLj4ErWzrVwg=
github.com/aws/aws-sdk-go-v2/credentials v1.17.27 h1:2raNba6gr2IfA0eqqiP2XiQ0UVOpGPgDSi0I9iAP+UI=
github.com/aws/aws-sdk-go-v2/credentials v1.17.27/go.mod h1:gniiwbGahQByxan6YjQUMcW4Aov6bLC3m+evgcoN4r4=
github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue v1.14.10 h1:orAIBscNu5aIjDOnKIrjO+IUFPMLKj3Lp0bPf4chiPc=
github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue v1.14.10/go.mod h1:GNjJ8daGhv10hmQYCnmkV8HuY6xXOXV4vzBssSjEIlU=
github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue v1.15.0 h1:zExbglw6JfQeXPLHmWg6vxOXdkvuZkEKRVo69scPd4M=
github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue v1.15.0/go.mod h1:bswOrGH35stnF9k41t5gKQ8b+j6B4SLe6cF3xHuJG6E=
github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression v1.7.35 h1:KX0BhLub8MxdzV9Le8o5FbVe9uIdupRpQNpWihYqOCo=
github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression v1.7.35/go.mod h1:AU11ceCYiyPIZqR6XCoPrFS02h8XwqC8Yfa+ZnE+OkA=
github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.16.11 h1:KreluoV8FZDEtI6Co2xuNk/UqI9iwMrOx/87PBNIKqw=
github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.16.11/go.mod h1:SeSUYBLsMYFoRvHE0Tjvn7kbxaUhl75CJi1sbfhMxkU=
github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.15 h1:SoNJ4RlFEQEbtDcCEt+QG56MY4fm4W8rYirAmq+/DdU=
github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.15/go.mod h1:U9ke74k1n2bf+RIgoX1SXFed1HLs51OgUSs+Ph0KJP8=
github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.16 h1:TNyt/+X43KJ9IJJMjKfa3bNTiZbUP7DeCxfbTROESwY=
github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.16/go.mod h1:2DwJF39FlNAUiX5pAc0UNeiz16lK2t7IaFcm0LFHEgc=
github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.15 h1:C6WHdGnTDIYETAm5iErQUiVNsclNx9qbJVPIt03B6bI=
github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.15/go.mod h1:ZQLZqhcu+JhSrA9/NXRm8SkDvsycE+JkV3WGY41e+IM=
github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.16 h1:jYfy8UPmd+6kJW5YhY0L1/KftReOGxI/4NtVSTh9O/I=
github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.16/go.mod h1:7ZfEPZxkW42Afq4uQB8H2E2e6ebh6mXTueEpYzjCzcs=
github.com/aws/aws-sdk-go-v2/internal/ini v1.8.0 h1:hT8rVHwugYE2lEfdFE0QWVo81lF7jMrYJVDWI+f+VxU=
github.com/aws/aws-sdk-go-v2/internal/ini v1.8.0/go.mod h1:8tu/lYfQfFe6IGnaOdrpVgEL2IrrDOf6/m9RQum4NkY=
github.com/aws/aws-sdk-go-v2/internal/v4a v1.3.16 h1:mimdLQkIX1zr8GIPY1ZtALdBQGxcASiBd2MOp8m/dMc=
github.com/aws/aws-sdk-go-v2/internal/v4a v1.3.16/go.mod h1:YHk6owoSwrIsok+cAH9PENCOGoH5PU2EllX4vLtSrsY=
github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider v1.43.1 h1:sUmqM7zfIHud8iY+fTGcnJXZIVLVcepUv0Vflvmya58=
github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider v1.43.1/go.mod h1:aynIysFCBIq18wfN2GrIYAeofOnQKV3LtkjyrQKfaFY=
github.com/aws/aws-sdk-go-v2/service/dynamodb v1.34.4 h1:utG3S4T+X7nONPIpRoi1tVcQdAdJxntiVS2yolPJyXc=
github.com/aws/aws-sdk-go-v2/service/dynamodb v1.34.4/go.mod h1:q9vzW3Xr1KEXa8n4waHiFt1PrppNDlMymlYP+xpsFbY=
github.com/aws/aws-sdk-go-v2/service/dynamodb v1.34.6 h1:LKZuRTlh8RszjuWcUwEDvCGwjx5olHPp6ZOepyZV5p8=
github.com/aws/aws-sdk-go-v2/service/dynamodb v1.34.6/go.mod h1:s2fYaueBuCnwv1XQn6T8TfShxJWusv5tWPMcL+GY6+g=
github.com/aws/aws-sdk-go-v2/service/dynamodbstreams v1.22.3 h1:r27/FnxLPixKBRIlslsvhqscBuMK8uysCYG9Kfgm098=
github.com/aws/aws-sdk-go-v2/service/dynamodbstreams v1.22.3/go.mod h1:jqOFyN+QSWSoQC+ppyc4weiO8iNQXbzRbxDjQ1ayYd4=
github.com/aws/aws-sdk-go-v2/service/dynamodbstreams v1.22.5 h1:sM/SaWUKPtsCcXE0bHZPUG4jjCbFbxakyptXQbYLrdU=
github.com/aws/aws-sdk-go-v2/service/dynamodbstreams v1.22.5/go.mod h1:3YxVsEoCNYOLIbdA+cCXSp1fom9hrhyB1DsCiYryCaQ=
github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.3 h1:dT3MqvGhSoaIhRseqw2I0yH81l7wiR2vjs57O51EAm8=
github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.3/go.mod h1:GlAeCkHwugxdHaueRr4nhPuY+WW+gR8UjlcqzPr1SPI=
github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.4 h1:KypMCbLPPHEmf9DgMGw51jMj77VfGPAN2Kv4cfhlfgI=
github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.4/go.mod h1:Vz1JQXliGcQktFTN/LN6uGppAIRoLBR2bMvIMP0gOjc=
github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.3.18 h1:GckUnpm4EJOAio1c8o25a+b3lVfwVzC9gnSBqiiNmZM=
github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.3.18/go.mod h1:Br6+bxfG33Dk3ynmkhsW2Z/t9D4+lRqdLDNCKi85w0U=
github.com/aws/aws-sdk-go-v2/service/internal/endpoint-discovery v1.9.16 h1:lhAX5f7KpgwyieXjbDnRTjPEUI0l3emSRyxXj1PXP8w=
github.com/aws/aws-sdk-go-v2/service/internal/endpoint-discovery v1.9.16/go.mod h1:AblAlCwvi7Q/SFowvckgN+8M3uFPlopSYeLlbNDArhA=
github.com/aws/aws-sdk-go-v2/service/internal/endpoint-discovery v1.9.17 h1:HDJGz1jlV7RokVgTPfx1UHBHANC0N5Uk++xgyYgz5E0=
github.com/aws/aws-sdk-go-v2/service/internal/endpoint-discovery v1.9.17/go.mod h1:5szDu6TWdRDytfDxUQVv2OYfpTQMKApVFyqpm+TcA98=
github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.17 h1:HGErhhrxZlQ044RiM+WdoZxp0p+EGM62y3L6pwA4olE=
github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.17/go.mod h1:RkZEx4l0EHYDJpWppMJ3nD9wZJAa8/0lq9aVC+r2UII=
github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.18 h1:tJ5RnkHCiSH0jyd6gROjlJtNwov0eGYNz8s8nFcR0jQ=
github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.18/go.mod h1:++NHzT+nAF7ZPrHPsA+ENvsXkOO8wEu+C6RXltAG4/c=
github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.17.16 h1:jg16PhLPUiHIj8zYIW6bqzeQSuHVEiWnGA0Brz5Xv2I=
github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.17.16/go.mod h1:Uyk1zE1VVdsHSU7096h/rwnXDzOzYQVl+FNPhPw7ShY=
github.com/aws/aws-sdk-go-v2/service/s3 v1.60.1 h1:mx2ucgtv+MWzJesJY9Ig/8AFHgoE5FwLXwUVgW/FGdI=
github.com/aws/aws-sdk-go-v2/service/s3 v1.60.1/go.mod h1:BSPI0EfnYUuNHPS0uqIo5VrRwzie+Fp+YhQOUs16sKI=
github.com/aws/aws-sdk-go-v2/service/sso v1.22.4 h1:BXx0ZIxvrJdSgSvKTZ+yRBeSqqgPM89VPlulEcl37tM=
github.com/aws/aws-sdk-go-v2/service/sso v1.22.4/go.mod h1:ooyCOXjvJEsUw7x+ZDHeISPMhtwI3ZCB7ggFMcFfWLU=
github.com/aws/aws-sdk-go-v2/service/ssooidc v1.26.4 h1:yiwVzJW2ZxZTurVbYWA7QOrAaCYQR72t0wrSBfoesUE=
github.com/aws/aws-sdk-go-v2/service/ssooidc v1.26.4/go.mod h1:0oxfLkpz3rQ/CHlx5hB7H69YUpFiI1tql6Q6Ne+1bCw=
github.com/aws/aws-sdk-go-v2/service/sts v1.30.3 h1:ZsDKRLXGWHk8WdtyYMoGNO7bTudrvuKpDKgMVRlepGE=
github.com/aws/aws-sdk-go-v2/service/sts v1.30.3/go.mod h1:zwySh8fpFyXp9yOr/KVzxOl8SRqgf/IDw5aUt9UKFcQ=
github.com/aws/smithy-go v1.20.3 h1:ryHwveWzPV5BIof6fyDvor6V3iUL7nTfiTKXHiW05nE=
github.com/aws/smithy-go v1.20.3/go.mod h1:krry+ya/rV9RDcV/Q16kpu6ypI4K2czasz0NC3qS14E=
github.com/aws/smithy-go v1.20.4 h1:2HK1zBdPgRbjFOHlfeQZfpC4r72MOb9bZkiFwggKO+4=
github.com/aws/smithy-go v1.20.4/go.mod h1:irrKGvNn1InZwb2d7fkIRNucdfwR8R+Ts3wxYa/cJHg=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/jmespath/go-jmespath v0.4.0 h1:BEgLn5cpjn8UN1mAw4NjwDrS35OdebyEtFe+9YPoQUg=
github.com/jmespath/go-jmespath v0.4.0/go.mod h1:T8mJZnbsbmF+m6zOOFylbeCJqk5+pHWvzYPziyZiYoo=
github.com/jmespath/go-jmespath/internal/testify v1.5.1/go.mod h1:L3OGu8Wl2/fWfCI6z80xFu9LTZmf1ZRjMHUOPmWr69U=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=

================
File: internal/db/dynamodb.go
================
package db

import (
	"context"
	"fmt"
	"log"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

var dbClient *dynamodb.Client

func init() {
	cfg, err := config.LoadDefaultConfig(context.TODO())
	if err != nil {
		log.Fatalf("Unable to load SDK config, %v", err)
	}

	dbClient = dynamodb.NewFromConfig(cfg)
}

type User struct {
	UID    string `dynamodbav:"uid"`
	Username  string `dynamodbav:"username"`
	Email     string `dynamodbav:"email"`
	CreatedAt string `dynamodbav:"created_at"`
}

type File struct {
	FileID    string `dynamodbav:"FileID"`
	UserID    string `dynamodbav:"UserID"`
	FileName  string `dynamodbav:"FileName"`
	FileSize  int64  `dynamodbav:"FileSize"`
	FileType  string `dynamodbav:"FileType"`
	CreatedAt string `dynamodbav:"CreatedAt"`
	UpdatedAt string `dynamodbav:"UpdatedAt"`
}

func CreateUser(ctx context.Context, user User) error {
	item, err := attributevalue.MarshalMap(user)
	if err != nil {
		return fmt.Errorf("failed to marshal user: %v", err)
	}

	_, err = dbClient.PutItem(ctx, &dynamodb.PutItemInput{
		TableName: aws.String("users"),
		Item: item,
	})

	if err != nil {
		return fmt.Errorf("failed to create user in DynamoDB: %v", err)
	}

	return nil
}

func GetUser(ctx context.Context, uid string) (*User, error) {
	res, err := dbClient.GetItem(ctx, &dynamodb.GetItemInput{
		TableName: aws.String(("users")),
		Key: map[string]types.AttributeValue {
			"uid": &types.AttributeValueMemberS{Value: uid},
		},
	})

	if err != nil {
		return nil, err
	}

	if res.Item == nil {
		return nil, nil
	}

	var user User
	err = attributevalue.UnmarshalMap(res.Item, &user)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

func CreateFile(ctx context.Context, file File) error {
	item, err := attributevalue.MarshalMap(file)
	if err != nil {
		return fmt.Errorf("failed to marshal file: %v", err)
	}

	// Log the marshalled item
	log.Printf("Marshalled item: %+v", item)

	_, err = dbClient.PutItem(ctx, &dynamodb.PutItemInput{
		TableName: aws.String("FileMetadata"), // Make sure this matches your actual table name
		Item:      item,
	})

	if err != nil {
		return fmt.Errorf("failed to create file in DynamoDB: %v", err)
	}

	return nil
}

func GetFile(ctx context.Context, fileID string) (*File, error) {
	res, err := dbClient.GetItem(ctx, &dynamodb.GetItemInput{
		TableName: aws.String("FileMetadata"),
		Key: map[string]types.AttributeValue{
			"FileID": &types.AttributeValueMemberS{Value: fileID},
		},
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get file: %v", err)
	}

	if res.Item == nil {
		return nil, nil
	}

	var file File
	err = attributevalue.UnmarshalMap(res.Item, &file)
	if err != nil {
		return nil, err
	}

	return &file, nil
}

func ListUserFiles(ctx context.Context, userID string) ([]File, error) {
	input := &dynamodb.QueryInput{
		TableName: aws.String("FileMetadata"),
		IndexName: aws.String("UserID-index"),
		KeyConditionExpression: aws.String("UserID = :uid"),
		ExpressionAttributeValues: map[string]types.AttributeValue{
			":uid": &types.AttributeValueMemberS{Value: userID},
		},
	}

	res, err := dbClient.Query(ctx, input)
	if err != nil {
		return nil, fmt.Errorf("failed to query user files: %v", err)
	}

	var files []File
	err = attributevalue.UnmarshalListOfMaps(res.Items, &files)
	if err != nil {
		return nil, fmt.Errorf("failed the unmarshal files: %v", err)
	}

	return files, nil
}

func UpdateFile(ctx context.Context, file File) error {
	update := expression.Set(expression.Name("FileSize"), expression.Value(file.FileSize)).
		Set(expression.Name("FileType"), expression.Value(file.FileType)).
		Set(expression.Name("UpdatedAt"), expression.Value(file.UpdatedAt))

	expr, err := expression.NewBuilder().WithUpdate(update).Build()
	if err != nil {
		log.Printf("couldnt build expression for update: %v\n", err)
		return err
	}

	_, err = dbClient.UpdateItem(ctx, &dynamodb.UpdateItemInput{
		TableName: aws.String("FileMetadata"),
		Key: map[string]types.AttributeValue{
			"FileID": &types.AttributeValueMemberS{Value: file.FileID},
		},
		ExpressionAttributeNames: expr.Names(),
		ExpressionAttributeValues: expr.Values(),
		UpdateExpression: expr.Update(),
		ReturnValues: types.ReturnValueUpdatedNew,
	})

	if err != nil {
		log.Printf("couldnt update file %v: %v", file.FileID, err)
		return err
	}

	log.Printf("successfully updated file metadata for fileID: %s", file.FileID)
	return nil
}

func DeleteFile(ctx context.Context, fileID string, userID string) error {
	file, err := GetFile(ctx, fileID)
	if err != nil {
		return fmt.Errorf("failed to get file: %v", err)
	}
	if file == nil {
		return fmt.Errorf("file not found")
	}

	if file.UserID != userID {
		return fmt.Errorf("unauthorized: file does not belong to the user")
	}

	_, err = dbClient.DeleteItem(ctx, &dynamodb.DeleteItemInput{
		TableName: aws.String("FileMetadata"),
		Key: map[string]types.AttributeValue{
			"FileID": &types.AttributeValueMemberS{Value: fileID},
		},
	})

	if err != nil {
		return fmt.Errorf("failed to delete file: %v", err)
	}

	return nil
}

================
File: internal/handlers/create_file.go
================
package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/google/uuid"
	"github.com/johnnynu/agreatchaos/api/internal/db"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

func CreateFile(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
    log.Printf("Received request: %+v", request)

    var input struct {
        FileName string `json:"file_name"`
        FileSize int64  `json:"file_size"`
        FileType string `json:"file_type"`
    }

    err := json.Unmarshal([]byte(request.Body), &input)
    if err != nil {
        log.Printf("Error unmarshalling request body: %v", err)
        return utils.ResponseError(err)
    }

    // Extract userID from JWT claims
    var userID string
	if jwt, ok := request.RequestContext.Authorizer["jwt"].(map[string]interface{}); ok {
		if claims, ok := jwt["claims"].(map[string]interface{}); ok {
			log.Printf("claims: %v", claims)
			if sub, ok := claims["sub"].(string); ok {
				log.Printf("sub: %v", sub)
				userID = sub
			}
		}
	}

    if userID == "" {
        log.Println("Unable to extract user ID from JWT claims")
        return utils.ResponseError(fmt.Errorf("unable to extract user ID from JWT claims"))
    }

    file := db.File{
        FileID:    uuid.New().String(),
        UserID:    userID,
        FileName:  input.FileName,
        FileSize:  input.FileSize,
        FileType:  input.FileType,
        CreatedAt: time.Now().Format(time.RFC3339),
        UpdatedAt: time.Now().Format(time.RFC3339),
    }

    log.Printf("Attempting to create file: %+v", file)

    err = db.CreateFile(ctx, file)
    if err != nil {
        log.Printf("Error creating file: %v", err)
        return utils.ResponseError(err)
    }

    return utils.ResponseOK(file)
}

================
File: internal/handlers/dbstream.go
================
package handlers

import (
	"context"
	"fmt"
	"log"

	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	"github.com/johnnynu/agreatchaos/api/internal/db"
)

func HandleStream(ctx context.Context, e events.DynamoDBEvent) error {
	for _, record := range e.Records {
		if record.EventName == "INSERT" || record.EventName == "MODIFY" {
			convertedImage, err := convertDDBStreamImage(record.Change.NewImage)
			if err != nil {
				log.Printf("Error converting DynamoDB stream image: %v", err)
				continue
			}

			var file db.File
			err = attributevalue.UnmarshalMap(convertedImage, &file)
			if err != nil {
				log.Printf("Error unmarshalling DynamoDB event: %v", err)
				continue
			}

			fmt.Printf("File updated: %s\n", file.FileName)
			// Here you can implement real-time notifications or trigger other processes
		} else if record.EventName == "REMOVE" {
			convertedImage, err := convertDDBStreamImage(record.Change.OldImage)
			if err != nil {
				log.Printf("Error converting DynamoDB stream image: %v", err)
				continue
			}

			var file db.File
			err = attributevalue.UnmarshalMap(convertedImage, &file)
			if err != nil {
				log.Printf("Error unmarshalling DynamoDB event: %v", err)
				continue
			}

			fmt.Printf("File deleted: %s\n", file.FileName)
			// Here you can implement cleanup processes or notifications
		}
	}

	return nil
}

func convertDDBStreamImage(image map[string]events.DynamoDBAttributeValue) (map[string]types.AttributeValue, error) {
	converted := make(map[string]types.AttributeValue)

	for k, v := range image {
		switch v.DataType() {
		case events.DataTypeString:
			converted[k] = &types.AttributeValueMemberS{Value: v.String()}
		case events.DataTypeNumber:
			converted[k] = &types.AttributeValueMemberN{Value: v.Number()}
		case events.DataTypeBinary:
			converted[k] = &types.AttributeValueMemberB{Value: v.Binary()}
		case events.DataTypeBoolean:
			converted[k] = &types.AttributeValueMemberBOOL{Value: v.Boolean()}
		case events.DataTypeNull:
			converted[k] = &types.AttributeValueMemberNULL{Value: v.IsNull()}
		case events.DataTypeList:
			listValues, err := convertDDBStreamList(v.List())
			if err != nil {
				return nil, err
			}
			converted[k] = &types.AttributeValueMemberL{Value: listValues}
		case events.DataTypeMap:
			mapValues, err := convertDDBStreamImage(v.Map())
			if err != nil {
				return nil, err
			}
			converted[k] = &types.AttributeValueMemberM{Value: mapValues}
		case events.DataTypeStringSet:
			converted[k] = &types.AttributeValueMemberSS{Value: v.StringSet()}
		case events.DataTypeNumberSet:
			converted[k] = &types.AttributeValueMemberNS{Value: v.NumberSet()}
		case events.DataTypeBinarySet:
			converted[k] = &types.AttributeValueMemberBS{Value: v.BinarySet()}
		default:
			return nil, fmt.Errorf("unsupported data type: %v", v.DataType())
		}
	}

	return converted, nil
}

func convertDDBStreamList(list []events.DynamoDBAttributeValue) ([]types.AttributeValue, error) {
	converted := make([]types.AttributeValue, len(list))

	for i, v := range list {
		switch v.DataType() {
		case events.DataTypeString:
			converted[i] = &types.AttributeValueMemberS{Value: v.String()}
		case events.DataTypeNumber:
			converted[i] = &types.AttributeValueMemberN{Value: v.Number()}
		case events.DataTypeBinary:
			converted[i] = &types.AttributeValueMemberB{Value: v.Binary()}
		case events.DataTypeBoolean:
			converted[i] = &types.AttributeValueMemberBOOL{Value: v.Boolean()}
		case events.DataTypeNull:
			converted[i] = &types.AttributeValueMemberNULL{Value: v.IsNull()}
		case events.DataTypeList:
			listValues, err := convertDDBStreamList(v.List())
			if err != nil {
				return nil, err
			}
			converted[i] = &types.AttributeValueMemberL{Value: listValues}
		case events.DataTypeMap:
			mapValues, err := convertDDBStreamImage(v.Map())
			if err != nil {
				return nil, err
			}
			converted[i] = &types.AttributeValueMemberM{Value: mapValues}
		case events.DataTypeStringSet:
			converted[i] = &types.AttributeValueMemberSS{Value: v.StringSet()}
		case events.DataTypeNumberSet:
			converted[i] = &types.AttributeValueMemberNS{Value: v.NumberSet()}
		case events.DataTypeBinarySet:
			converted[i] = &types.AttributeValueMemberBS{Value: v.BinarySet()}
		default:
			return nil, fmt.Errorf("unsupported data type: %v", v.DataType())
		}
	}

	return converted, nil
}

================
File: internal/handlers/delete_file.go
================
package handlers

import (
	"context"
	"fmt"
	"log"

	"github.com/aws/aws-lambda-go/events"
	"github.com/johnnynu/agreatchaos/api/internal/db"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

func DeleteFile(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	log.Printf("Received request: %+v", request)

	fileID, ok := request.PathParameters["fileId"]
	if !ok || fileID == "" {
		log.Println("FileID not found in path parameters")
		return utils.ResponseError(fmt.Errorf("fileID is required"))
	}
	log.Printf("FileID to delete: %s", fileID)

    // Extract userID from JWT claims
    var userID string
	if jwt, ok := request.RequestContext.Authorizer["jwt"].(map[string]interface{}); ok {
		if claims, ok := jwt["claims"].(map[string]interface{}); ok {
			log.Printf("claims: %v", claims)
			if sub, ok := claims["sub"].(string); ok {
				log.Printf("sub: %v", sub)
				userID = sub
			}
		}
	}

	if userID == "" {
        log.Println("Unable to extract user ID from JWT claims")
        return utils.ResponseError(fmt.Errorf("unable to extract user ID from JWT claims"))
    }

	if userID == "" {
        log.Println("Unable to extract user ID from JWT claims")
        return utils.ResponseError(fmt.Errorf("unable to extract user ID from JWT claims"))
    }

	err := db.DeleteFile(ctx, fileID, userID)
	if err != nil {
		log.Printf("Error deleting file: %v", err)
		return utils.ResponseError(err)
	}

	log.Printf("File %s deleted successfully", fileID)

	return events.APIGatewayProxyResponse{
		StatusCode: 200,
		Body: fmt.Sprintf("File %s deleted successfully", fileID),
	}, nil
}

================
File: internal/handlers/generate_download_url.go
================
package handlers

import (
	"context"
	"errors"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

func GenerateDownloadURL(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	fileName := request.QueryStringParameters["fileName"]
	if fileName == "" {
		return utils.ResponseError(errors.New("fileName is required"))
	}

	cfg, err := config.LoadDefaultConfig(ctx)
	if err != nil {
		return utils.ResponseError(err)
	}

	s3Client := s3.NewFromConfig(cfg)

	// Generate pre signed url
	presignClient := s3.NewPresignClient(s3Client)
	presignedUrl, err := presignClient.PresignGetObject(ctx, &s3.GetObjectInput{
		Bucket: aws.String("chaosfiles-filestorage"),
		Key: aws.String(fileName),
	}, s3.WithPresignExpires(time.Minute * 15))

	if err != nil {
		return utils.ResponseError(err)
	}

	// Return the presigned url
	return utils.ResponseOK(map[string]string{
		"downloadUrl": presignedUrl.URL,
	})
}

================
File: internal/handlers/generate_upload_url.go
================
package handlers

import (
	"context"
	"errors"
	"fmt"
	"log"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"github.com/google/uuid"
	"github.com/johnnynu/agreatchaos/api/internal/db"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

func GenerateUploadURL(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	fileName := request.QueryStringParameters["fileName"]
	if fileName == "" {
		return utils.ResponseError(errors.New("fileName is required"))
	}

	var userID string
	if jwt, ok := request.RequestContext.Authorizer["jwt"].(map[string]interface{}); ok {
		if claims, ok := jwt["claims"].(map[string]interface{}); ok {
			log.Printf("claims: %v", claims)
			if sub, ok := claims["sub"].(string); ok {
				log.Printf("sub: %v", sub)
				userID = sub
			}
		}
	}

    if userID == "" {
        log.Println("Unable to extract user ID from JWT claims")
        return utils.ResponseError(fmt.Errorf("unable to extract user ID from JWT claims"))
    }

	fileID := uuid.New().String()

    file := db.File{
        FileID:    fileID,
        UserID:    userID,
        FileName:  fileName,
        CreatedAt: time.Now().Format(time.RFC3339),
        UpdatedAt: time.Now().Format(time.RFC3339),
    }

    log.Printf("Attempting to create file: %+v", file)

    err := db.CreateFile(ctx, file)
    if err != nil {
        log.Printf("Error creating file: %v", err)
        return utils.ResponseError(err)
    }

	cfg, err := config.LoadDefaultConfig(ctx)
	if err != nil {
		return utils.ResponseError(err)
	}

	s3Client := s3.NewFromConfig(cfg)

	// Generate pre signed url
	presignClient := s3.NewPresignClient(s3Client)
	presignedUrl, err := presignClient.PresignPutObject(ctx, &s3.PutObjectInput{
		Bucket: aws.String("chaosfiles-filestorage"),
		Key: aws.String(fileID),
	}, s3.WithPresignExpires(time.Minute * 15))

	if err != nil {
		return utils.ResponseError(err)
	}

    response := struct {
        UploadURL string `json:"uploadUrl"`
        FileID    string `json:"fileID"`
    }{
        UploadURL: presignedUrl.URL,
        FileID:    fileID,
    }

	// Return the presigned url
	return utils.ResponseOK(response)
}

================
File: internal/handlers/list_files.go
================
package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"log"

	"github.com/aws/aws-lambda-go/events"
	"github.com/johnnynu/agreatchaos/api/internal/db"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

func ListFiles(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	log.Printf("Received request: %+v: ", request)

    // Extract userID from JWT claims
    var userID string
	if jwt, ok := request.RequestContext.Authorizer["jwt"].(map[string]interface{}); ok {
		if claims, ok := jwt["claims"].(map[string]interface{}); ok {
			log.Printf("claims: %v", claims)
			if sub, ok := claims["sub"].(string); ok {
				log.Printf("sub: %v", sub)
				userID = sub
			}
		}
	}

	if userID == "" {
        log.Println("Unable to extract user ID from JWT claims")
        return utils.ResponseError(fmt.Errorf("unable to extract user ID from JWT claims"))
    }

	files, err := db.ListUserFiles(ctx, userID)
	if err != nil {
		log.Printf("Error listing files: %v", err)
		return utils.ResponseError(err)
	}

	// Convert files to JSON
	resBody, err := json.Marshal(files)
	if err != nil {
		log.Printf("Error marshalling response: %v", err)
		return utils.ResponseError(err)
	}

	return events.APIGatewayProxyResponse{
		StatusCode: 200,
		Headers: map[string]string{
			"Content-Type": "application/json",
		},
		Body: string(resBody),
	}, nil
}

================
File: internal/handlers/preview_file.go
================
package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"log"

	"github.com/aws/aws-lambda-go/events"
	"github.com/johnnynu/agreatchaos/api/internal/db"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

func PreviewFile(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
    log.Printf("Received request: %+v", request)
    log.Printf("Context: %+v", ctx)
    log.Printf("Path parameters: %+v", request.PathParameters)
    log.Printf("Query string parameters: %+v", request.QueryStringParameters)
    log.Printf("Headers: %+v", request.Headers)

    fileID, ok := request.PathParameters["fileId"]
    if !ok || fileID == "" {
        log.Printf("FileID not found in path parameters")
        return utils.ResponseError(fmt.Errorf("fileID is required"))
    }
    log.Printf("FileID: %s", fileID)

    // get file details
    file, err := db.GetFile(ctx, fileID)
    if err != nil {
        log.Printf("Error getting file: %v", err)
        return utils.ResponseError(err)
    }

    if file == nil {
        log.Printf("File not found for ID: %s", fileID)
        return utils.ResponseError(utils.ErrNotFound)
    }

    log.Printf("File found: %+v", file)

    res, err := json.Marshal(file)
    if err != nil {
        log.Printf("Error marshalling response: %v", err)
        return utils.ResponseError(err)
    }

    log.Printf("Sending response: %s", string(res))

    return events.APIGatewayProxyResponse{
        StatusCode: 200,
        Headers: map[string]string{
            "Content-Type": "application/json",
        },
        Body: string(res),
    }, nil
}

================
File: internal/handlers/process_upload.go
================
package handlers

import (
	"context"
	"log"
	"mime"
	"path/filepath"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/johnnynu/agreatchaos/api/internal/db"
)

func ProcessUpload(ctx context.Context, s3Event events.S3Event) error {
    for _, record := range s3Event.Records {
        key := record.S3.Object.Key // fileID
        size := record.S3.Object.Size

        // Fetch file metadata
        file, err := db.GetFile(ctx, key)
        if err != nil {
            log.Printf("Error fetching file metadata: %v", err)
            return err
        }

        // Update file metadata
        file.FileSize = size
        file.FileType = getFileType(key)
		file.UpdatedAt = time.Now().Format(time.RFC3339)

        err = db.UpdateFile(ctx, *file)
        if err != nil {
            log.Printf("Error updating file metadata: %v", err)
            return err
        }

        log.Printf("Successfully processed upload for file: %s", key)
    }

    return nil
}

func getFileType(fileName string) string {
    ext := filepath.Ext(fileName)
	if ext == "" {
		return "application/octet-stream"
	}

	mimeType := mime.TypeByExtension(ext)
	if mimeType == "" {
		return "application/octet-stream"
	}

	return mimeType
}

================
File: internal/handlers/signin_user.go
================
package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider"
	"github.com/johnnynu/agreatchaos/api/internal/db"
)

func SigninUser(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	log.Printf("TESTReceived request headers: %v+", request.Headers)
	log.Println()

	// Extract cognito token from request
	authHeader := request.Headers["authorization"]
	log.Printf("TEST AUTH HEADER: %s", authHeader)
	log.Println()
	if authHeader == "" {
		log.Println("No auth token provided")
		return events.APIGatewayProxyResponse{StatusCode: 401, Body: "No token provided"}, nil
	}

	log.Printf("Token received: %s...", authHeader[:10])

	token := strings.TrimPrefix(authHeader, "Bearer ")
	if token == "" {
        log.Println("Empty token after removing Bearer prefix")
        return events.APIGatewayProxyResponse{StatusCode: 401, Body: "Invalid token format"}, nil
    }

	log.Printf("Token received (first 20 chars): %s...", token[:20])

	// verify cognito token
	claims, err := verifyToken(ctx, token)
	if err != nil {
		log.Printf("Token verification failed: %v", err)
		return events.APIGatewayProxyResponse{StatusCode: 401}, err
	}

	// extract user info from claims
	uid, ok := claims["sub"].(string)
	if !ok {
		log.Println("Unable to extract user ID from token claims")
		return events.APIGatewayProxyResponse{StatusCode: 400, Body: "Invalid token content"}, nil
	}
	email, _ := claims["email"].(string)

	log.Printf("Extracted user info - UID: %s, Email: %s", uid, email)

	// process any additional metadata from request body

	// Check if user already exists in db
	existingUser, err := db.GetUser(ctx, uid)
	if err != nil {
		log.Printf("Error checking existing user: %v", err)
		return events.APIGatewayProxyResponse{StatusCode: 500, Body: "Internal server error"}, err
	}

	isNewUser := existingUser == nil

	if isNewUser {
		user := db.User{
			UID:    uid,
			Email:     email,
			CreatedAt: time.Now().Format(time.RFC3339),
		}

		// Call CreateUser function
		err = db.CreateUser(ctx, user)
		if err != nil {
			log.Printf("Error creating new user: %v", err)
			return events.APIGatewayProxyResponse{StatusCode: 500, Body: "Failed to create new user"}, err
		}
		log.Println("New user created successfully")
	} else {
		log.Println("Existing user signed in")
	}

	res := struct {
		Message   string `json:"message"`
		IsNewUser bool   `json:"isNewUser"`
	}{
		Message:   "Sign-in successful",
		IsNewUser: isNewUser,
	}

	resBody, err := json.Marshal(res)
	if err != nil {
		log.Printf("Error creating response: %v", err)
		return events.APIGatewayProxyResponse{StatusCode: 500, Body: "Error creating response"}, nil
	}

	log.Println("Signin process completed successfully")
	return events.APIGatewayProxyResponse{
		StatusCode: 200,
		Body:       string(resBody),
		Headers: map[string]string{
			"Content-Type": "application/json",
		},
	}, nil
}

func verifyToken(ctx context.Context, token string) (map[string]interface{}, error) {
	cfg, err := config.LoadDefaultConfig(ctx)
	if err != nil {
		return nil, fmt.Errorf("unable to load SDK config, %v", err)
	}

	cognitoClient := cognitoidentityprovider.NewFromConfig(cfg)

	if token == "" {
		return nil, fmt.Errorf("empty token")
	}

	input := &cognitoidentityprovider.GetUserInput{
		AccessToken: aws.String(token),
	}

	result, err := cognitoClient.GetUser(ctx, input)
	if err != nil {
		return nil, fmt.Errorf("error verifying token, %v", err)
	}

	claims := make(map[string]interface{})
	for _, attr := range result.UserAttributes {
		claims[*attr.Name] = *attr.Value
	}

	log.Println("Token verified successfully")
	return claims, nil
}

================
File: pkg/utils/response.go
================
// pkg/utils/response.go
package utils

import (
	"encoding/json"
	"errors"

	"github.com/aws/aws-lambda-go/events"
)

var ErrNotFound = errors.New("resource not found")

func ResponseOK(body interface{}) (events.APIGatewayProxyResponse, error) {
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return ResponseError(err)
	}

	return events.APIGatewayProxyResponse{
		StatusCode: 200,
		Body:       string(bodyBytes),
		Headers: map[string]string{
			"Content-Type": "application/json",
		},
	}, nil
}

func ResponseError(err error) (events.APIGatewayProxyResponse, error) {
	statusCode := 500
	if errors.Is(err, ErrNotFound) {
		statusCode = 404
	}
	return events.APIGatewayProxyResponse{
		StatusCode: statusCode,
		Body:       err.Error(),
		Headers: map[string]string{
			"Content-Type": "application/json",
		},
	}, nil
}

================
File: cmd/lambda/create_file/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.CreateFile)
}

================
File: cmd/lambda/delete_file/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.DeleteFile)
}

================
File: cmd/lambda/generate_upload_url/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.GenerateUploadURL)
}

================
File: cmd/lambda/generate_download_url/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.GenerateDownloadURL)
}

================
File: cmd/lambda/handle_upload/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.ProcessUpload)
}

================
File: cmd/lambda/list_files/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.ListFiles)
}

================
File: cmd/lambda/preview_file/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {

	lambda.Start(handlers.PreviewFile)
}

================
File: cmd/lambda/signin_user/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.SigninUser)
}

================
File: cmd/lambda/stream/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.HandleStream)
}

================
File: internal/db/dynamodb.go
================
package db

import (
	"context"
	"fmt"
	"log"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

var dbClient *dynamodb.Client

func init() {
	cfg, err := config.LoadDefaultConfig(context.TODO())
	if err != nil {
		log.Fatalf("Unable to load SDK config, %v", err)
	}

	dbClient = dynamodb.NewFromConfig(cfg)
}

type User struct {
	UID    string `dynamodbav:"uid"`
	Username  string `dynamodbav:"username"`
	Email     string `dynamodbav:"email"`
	CreatedAt string `dynamodbav:"created_at"`
}

type File struct {
	FileID    string `dynamodbav:"FileID"`
	UserID    string `dynamodbav:"UserID"`
	FileName  string `dynamodbav:"FileName"`
	FileSize  int64  `dynamodbav:"FileSize"`
	FileType  string `dynamodbav:"FileType"`
	CreatedAt string `dynamodbav:"CreatedAt"`
	UpdatedAt string `dynamodbav:"UpdatedAt"`
}

func CreateUser(ctx context.Context, user User) error {
	item, err := attributevalue.MarshalMap(user)
	if err != nil {
		return fmt.Errorf("failed to marshal user: %v", err)
	}

	_, err = dbClient.PutItem(ctx, &dynamodb.PutItemInput{
		TableName: aws.String("users"),
		Item: item,
	})

	if err != nil {
		return fmt.Errorf("failed to create user in DynamoDB: %v", err)
	}

	return nil
}

func GetUser(ctx context.Context, uid string) (*User, error) {
	res, err := dbClient.GetItem(ctx, &dynamodb.GetItemInput{
		TableName: aws.String(("users")),
		Key: map[string]types.AttributeValue {
			"uid": &types.AttributeValueMemberS{Value: uid},
		},
	})

	if err != nil {
		return nil, err
	}

	if res.Item == nil {
		return nil, nil
	}

	var user User
	err = attributevalue.UnmarshalMap(res.Item, &user)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

func CreateFile(ctx context.Context, file File) error {
	item, err := attributevalue.MarshalMap(file)
	if err != nil {
		return fmt.Errorf("failed to marshal file: %v", err)
	}

	// Log the marshalled item
	log.Printf("Marshalled item: %+v", item)

	_, err = dbClient.PutItem(ctx, &dynamodb.PutItemInput{
		TableName: aws.String("FileMetadata"), // Make sure this matches your actual table name
		Item:      item,
	})

	if err != nil {
		return fmt.Errorf("failed to create file in DynamoDB: %v", err)
	}

	return nil
}

func GetFile(ctx context.Context, fileID string) (*File, error) {
	res, err := dbClient.GetItem(ctx, &dynamodb.GetItemInput{
		TableName: aws.String("FileMetadata"),
		Key: map[string]types.AttributeValue{
			"FileID": &types.AttributeValueMemberS{Value: fileID},
		},
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get file: %v", err)
	}

	if res.Item == nil {
		return nil, nil
	}

	var file File
	err = attributevalue.UnmarshalMap(res.Item, &file)
	if err != nil {
		return nil, err
	}

	return &file, nil
}

func ListUserFiles(ctx context.Context, userID string) ([]File, error) {
	input := &dynamodb.QueryInput{
		TableName: aws.String("FileMetadata"),
		IndexName: aws.String("UserID-index"),
		KeyConditionExpression: aws.String("UserID = :uid"),
		ExpressionAttributeValues: map[string]types.AttributeValue{
			":uid": &types.AttributeValueMemberS{Value: userID},
		},
	}

	res, err := dbClient.Query(ctx, input)
	if err != nil {
		return nil, fmt.Errorf("failed to query user files: %v", err)
	}

	var files []File
	err = attributevalue.UnmarshalListOfMaps(res.Items, &files)
	if err != nil {
		return nil, fmt.Errorf("failed the unmarshal files: %v", err)
	}

	return files, nil
}

func UpdateFile(ctx context.Context, file File) error {
	update := expression.Set(expression.Name("FileSize"), expression.Value(file.FileSize)).
		Set(expression.Name("FileType"), expression.Value(file.FileType)).
		Set(expression.Name("UpdatedAt"), expression.Value(file.UpdatedAt))

	expr, err := expression.NewBuilder().WithUpdate(update).Build()
	if err != nil {
		log.Printf("couldnt build expression for update: %v\n", err)
		return err
	}

	_, err = dbClient.UpdateItem(ctx, &dynamodb.UpdateItemInput{
		TableName: aws.String("FileMetadata"),
		Key: map[string]types.AttributeValue{
			"FileID": &types.AttributeValueMemberS{Value: file.FileID},
		},
		ExpressionAttributeNames: expr.Names(),
		ExpressionAttributeValues: expr.Values(),
		UpdateExpression: expr.Update(),
		ReturnValues: types.ReturnValueUpdatedNew,
	})

	if err != nil {
		log.Printf("couldnt update file %v: %v", file.FileID, err)
		return err
	}

	log.Printf("successfully updated file metadata for fileID: %s", file.FileID)
	return nil
}

func DeleteFile(ctx context.Context, fileID string, userID string) error {
	file, err := GetFile(ctx, fileID)
	if err != nil {
		return fmt.Errorf("failed to get file: %v", err)
	}
	if file == nil {
		return fmt.Errorf("file not found")
	}

	if file.UserID != userID {
		return fmt.Errorf("unauthorized: file does not belong to the user")
	}

	_, err = dbClient.DeleteItem(ctx, &dynamodb.DeleteItemInput{
		TableName: aws.String("FileMetadata"),
		Key: map[string]types.AttributeValue{
			"FileID": &types.AttributeValueMemberS{Value: fileID},
		},
	})

	if err != nil {
		return fmt.Errorf("failed to delete file: %v", err)
	}

	return nil
}

================
File: pkg/utils/response.go
================
// pkg/utils/response.go
package utils

import (
	"encoding/json"
	"errors"

	"github.com/aws/aws-lambda-go/events"
)

var ErrNotFound = errors.New("resource not found")

func ResponseOK(body interface{}) (events.APIGatewayProxyResponse, error) {
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return ResponseError(err)
	}

	return events.APIGatewayProxyResponse{
		StatusCode: 200,
		Body:       string(bodyBytes),
		Headers: map[string]string{
			"Content-Type": "application/json",
		},
	}, nil
}

func ResponseError(err error) (events.APIGatewayProxyResponse, error) {
	statusCode := 500
	if errors.Is(err, ErrNotFound) {
		statusCode = 404
	}
	return events.APIGatewayProxyResponse{
		StatusCode: statusCode,
		Body:       err.Error(),
		Headers: map[string]string{
			"Content-Type": "application/json",
		},
	}, nil
}

================
File: internal/handlers/create_file.go
================
package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/google/uuid"
	"github.com/johnnynu/agreatchaos/api/internal/db"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

func CreateFile(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
    log.Printf("Received request: %+v", request)

    var input struct {
        FileName string `json:"file_name"`
        FileSize int64  `json:"file_size"`
        FileType string `json:"file_type"`
    }

    err := json.Unmarshal([]byte(request.Body), &input)
    if err != nil {
        log.Printf("Error unmarshalling request body: %v", err)
        return utils.ResponseError(err)
    }

    // Extract userID from JWT claims
    var userID string
	if jwt, ok := request.RequestContext.Authorizer["jwt"].(map[string]interface{}); ok {
		if claims, ok := jwt["claims"].(map[string]interface{}); ok {
			log.Printf("claims: %v", claims)
			if sub, ok := claims["sub"].(string); ok {
				log.Printf("sub: %v", sub)
				userID = sub
			}
		}
	}

    if userID == "" {
        log.Println("Unable to extract user ID from JWT claims")
        return utils.ResponseError(fmt.Errorf("unable to extract user ID from JWT claims"))
    }

    file := db.File{
        FileID:    uuid.New().String(),
        UserID:    userID,
        FileName:  input.FileName,
        FileSize:  input.FileSize,
        FileType:  input.FileType,
        CreatedAt: time.Now().Format(time.RFC3339),
        UpdatedAt: time.Now().Format(time.RFC3339),
    }

    log.Printf("Attempting to create file: %+v", file)

    err = db.CreateFile(ctx, file)
    if err != nil {
        log.Printf("Error creating file: %v", err)
        return utils.ResponseError(err)
    }

    return utils.ResponseOK(file)
}

================
File: internal/handlers/dbstream.go
================
package handlers

import (
	"context"
	"fmt"
	"log"

	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	"github.com/johnnynu/agreatchaos/api/internal/db"
)

func HandleStream(ctx context.Context, e events.DynamoDBEvent) error {
	for _, record := range e.Records {
		if record.EventName == "INSERT" || record.EventName == "MODIFY" {
			convertedImage, err := convertDDBStreamImage(record.Change.NewImage)
			if err != nil {
				log.Printf("Error converting DynamoDB stream image: %v", err)
				continue
			}

			var file db.File
			err = attributevalue.UnmarshalMap(convertedImage, &file)
			if err != nil {
				log.Printf("Error unmarshalling DynamoDB event: %v", err)
				continue
			}

			fmt.Printf("File updated: %s\n", file.FileName)
			// Here you can implement real-time notifications or trigger other processes
		} else if record.EventName == "REMOVE" {
			convertedImage, err := convertDDBStreamImage(record.Change.OldImage)
			if err != nil {
				log.Printf("Error converting DynamoDB stream image: %v", err)
				continue
			}

			var file db.File
			err = attributevalue.UnmarshalMap(convertedImage, &file)
			if err != nil {
				log.Printf("Error unmarshalling DynamoDB event: %v", err)
				continue
			}

			fmt.Printf("File deleted: %s\n", file.FileName)
			// Here you can implement cleanup processes or notifications
		}
	}

	return nil
}

func convertDDBStreamImage(image map[string]events.DynamoDBAttributeValue) (map[string]types.AttributeValue, error) {
	converted := make(map[string]types.AttributeValue)

	for k, v := range image {
		switch v.DataType() {
		case events.DataTypeString:
			converted[k] = &types.AttributeValueMemberS{Value: v.String()}
		case events.DataTypeNumber:
			converted[k] = &types.AttributeValueMemberN{Value: v.Number()}
		case events.DataTypeBinary:
			converted[k] = &types.AttributeValueMemberB{Value: v.Binary()}
		case events.DataTypeBoolean:
			converted[k] = &types.AttributeValueMemberBOOL{Value: v.Boolean()}
		case events.DataTypeNull:
			converted[k] = &types.AttributeValueMemberNULL{Value: v.IsNull()}
		case events.DataTypeList:
			listValues, err := convertDDBStreamList(v.List())
			if err != nil {
				return nil, err
			}
			converted[k] = &types.AttributeValueMemberL{Value: listValues}
		case events.DataTypeMap:
			mapValues, err := convertDDBStreamImage(v.Map())
			if err != nil {
				return nil, err
			}
			converted[k] = &types.AttributeValueMemberM{Value: mapValues}
		case events.DataTypeStringSet:
			converted[k] = &types.AttributeValueMemberSS{Value: v.StringSet()}
		case events.DataTypeNumberSet:
			converted[k] = &types.AttributeValueMemberNS{Value: v.NumberSet()}
		case events.DataTypeBinarySet:
			converted[k] = &types.AttributeValueMemberBS{Value: v.BinarySet()}
		default:
			return nil, fmt.Errorf("unsupported data type: %v", v.DataType())
		}
	}

	return converted, nil
}

func convertDDBStreamList(list []events.DynamoDBAttributeValue) ([]types.AttributeValue, error) {
	converted := make([]types.AttributeValue, len(list))

	for i, v := range list {
		switch v.DataType() {
		case events.DataTypeString:
			converted[i] = &types.AttributeValueMemberS{Value: v.String()}
		case events.DataTypeNumber:
			converted[i] = &types.AttributeValueMemberN{Value: v.Number()}
		case events.DataTypeBinary:
			converted[i] = &types.AttributeValueMemberB{Value: v.Binary()}
		case events.DataTypeBoolean:
			converted[i] = &types.AttributeValueMemberBOOL{Value: v.Boolean()}
		case events.DataTypeNull:
			converted[i] = &types.AttributeValueMemberNULL{Value: v.IsNull()}
		case events.DataTypeList:
			listValues, err := convertDDBStreamList(v.List())
			if err != nil {
				return nil, err
			}
			converted[i] = &types.AttributeValueMemberL{Value: listValues}
		case events.DataTypeMap:
			mapValues, err := convertDDBStreamImage(v.Map())
			if err != nil {
				return nil, err
			}
			converted[i] = &types.AttributeValueMemberM{Value: mapValues}
		case events.DataTypeStringSet:
			converted[i] = &types.AttributeValueMemberSS{Value: v.StringSet()}
		case events.DataTypeNumberSet:
			converted[i] = &types.AttributeValueMemberNS{Value: v.NumberSet()}
		case events.DataTypeBinarySet:
			converted[i] = &types.AttributeValueMemberBS{Value: v.BinarySet()}
		default:
			return nil, fmt.Errorf("unsupported data type: %v", v.DataType())
		}
	}

	return converted, nil
}

================
File: internal/handlers/delete_file.go
================
package handlers

import (
	"context"
	"fmt"
	"log"

	"github.com/aws/aws-lambda-go/events"
	"github.com/johnnynu/agreatchaos/api/internal/db"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

func DeleteFile(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	log.Printf("Received request: %+v", request)

	fileID, ok := request.PathParameters["fileId"]
	if !ok || fileID == "" {
		log.Println("FileID not found in path parameters")
		return utils.ResponseError(fmt.Errorf("fileID is required"))
	}
	log.Printf("FileID to delete: %s", fileID)

    // Extract userID from JWT claims
    var userID string
	if jwt, ok := request.RequestContext.Authorizer["jwt"].(map[string]interface{}); ok {
		if claims, ok := jwt["claims"].(map[string]interface{}); ok {
			log.Printf("claims: %v", claims)
			if sub, ok := claims["sub"].(string); ok {
				log.Printf("sub: %v", sub)
				userID = sub
			}
		}
	}

	if userID == "" {
        log.Println("Unable to extract user ID from JWT claims")
        return utils.ResponseError(fmt.Errorf("unable to extract user ID from JWT claims"))
    }

	if userID == "" {
        log.Println("Unable to extract user ID from JWT claims")
        return utils.ResponseError(fmt.Errorf("unable to extract user ID from JWT claims"))
    }

	err := db.DeleteFile(ctx, fileID, userID)
	if err != nil {
		log.Printf("Error deleting file: %v", err)
		return utils.ResponseError(err)
	}

	log.Printf("File %s deleted successfully", fileID)

	return events.APIGatewayProxyResponse{
		StatusCode: 200,
		Body: fmt.Sprintf("File %s deleted successfully", fileID),
	}, nil
}

================
File: internal/handlers/generate_download_url.go
================
package handlers

import (
	"context"
	"errors"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"github.com/johnnynu/agreatchaos/api/internal/db"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

func GenerateDownloadURL(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	fileID := request.QueryStringParameters["fileID"]
	if fileID == "" {
		return utils.ResponseError(errors.New("fileID is required"))
	}

	file, err := db.GetFile(ctx, fileID)
	if err != nil {
		return utils.ResponseError(err)
	}
	if file == nil {
		return utils.ResponseError(errors.New("file not found"))
	}

	cfg, err := config.LoadDefaultConfig(ctx)
	if err != nil {
		return utils.ResponseError(err)
	}

	s3Client := s3.NewFromConfig(cfg)

	// Generate pre signed url
	presignClient := s3.NewPresignClient(s3Client)
	presignedUrl, err := presignClient.PresignGetObject(ctx, &s3.GetObjectInput{
		Bucket: aws.String("chaosfiles-filestorage"),
		Key: aws.String(fileID),
	}, s3.WithPresignExpires(time.Minute * 15))

	if err != nil {
		return utils.ResponseError(err)
	}

	// Return the presigned url
	return utils.ResponseOK(map[string]string{
		"downloadUrl": presignedUrl.URL,
		"fileName": file.FileName,
	})
}

================
File: internal/handlers/generate_upload_url.go
================
package handlers

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"github.com/google/uuid"
	"github.com/johnnynu/agreatchaos/api/internal/db"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

type UploadURLRequest struct {
	FileName string `json:"fileName"`
	FileType string `json:"fileType"`
}

func GenerateUploadURL(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	log.Println("GenerateUploadURL function started")

	var  req UploadURLRequest
	err := json.Unmarshal([]byte(request.Body), &req)
	if err != nil {
		log.Printf("Error unmarshalling request body: %v", err)
		return utils.ResponseError(errors.New("invalid request body"))
	}

	if req.FileName == "" {
		log.Println("fileName is required")
		return utils.ResponseError(errors.New("fileName is required"))
	}

	var userID string
	if jwt, ok := request.RequestContext.Authorizer["jwt"].(map[string]interface{}); ok {
		if claims, ok := jwt["claims"].(map[string]interface{}); ok {
			log.Printf("claims: %v", claims)
			if sub, ok := claims["sub"].(string); ok {
				log.Printf("sub: %v", sub)
				userID = sub
			}
		}
	}

    if userID == "" {
        log.Println("Unable to extract user ID from JWT claims")
        return utils.ResponseError(fmt.Errorf("unable to extract user ID from JWT claims"))
    }

	fileID := uuid.New().String()

    file := db.File{
        FileID:    fileID,
        UserID:    userID,
        FileName:  req.FileName,
		FileType: req.FileType,
        CreatedAt: time.Now().Format(time.RFC3339),
        UpdatedAt: time.Now().Format(time.RFC3339),
    }

    log.Printf("Attempting to create file: %+v", file)

    err = db.CreateFile(ctx, file)
    if err != nil {
        log.Printf("Error creating file: %v", err)
        return utils.ResponseError(err)
    }

	cfg, err := config.LoadDefaultConfig(ctx)
	if err != nil {
		return utils.ResponseError(err)
	}

	s3Client := s3.NewFromConfig(cfg)

	// Generate pre signed url
	presignClient := s3.NewPresignClient(s3Client)
	presignedUrl, err := presignClient.PresignPutObject(ctx, &s3.PutObjectInput{
		Bucket: aws.String("chaosfiles-filestorage"),
		Key: aws.String(fileID),
	}, s3.WithPresignExpires(time.Minute * 15))

	if err != nil {
		return utils.ResponseError(err)
	}

    response := struct {
        UploadURL string `json:"uploadUrl"`
        FileID    string `json:"fileID"`
    }{
        UploadURL: presignedUrl.URL,
        FileID:    fileID,
    }

	// Return the presigned url
	return utils.ResponseOK(response)
}

================
File: internal/handlers/list_files.go
================
package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"log"

	"github.com/aws/aws-lambda-go/events"
	"github.com/johnnynu/agreatchaos/api/internal/db"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

func ListFiles(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	log.Printf("Received request: %+v: ", request)

    // Extract userID from JWT claims
    var userID string
	if jwt, ok := request.RequestContext.Authorizer["jwt"].(map[string]interface{}); ok {
		if claims, ok := jwt["claims"].(map[string]interface{}); ok {
			log.Printf("claims: %v", claims)
			if sub, ok := claims["sub"].(string); ok {
				log.Printf("sub: %v", sub)
				userID = sub
			}
		}
	}

	if userID == "" {
        log.Println("Unable to extract user ID from JWT claims")
        return utils.ResponseError(fmt.Errorf("unable to extract user ID from JWT claims"))
    }

	files, err := db.ListUserFiles(ctx, userID)
	if err != nil {
		log.Printf("Error listing files: %v", err)
		return utils.ResponseError(err)
	}

	// Convert files to JSON
	resBody, err := json.Marshal(files)
	if err != nil {
		log.Printf("Error marshalling response: %v", err)
		return utils.ResponseError(err)
	}

	return events.APIGatewayProxyResponse{
		StatusCode: 200,
		Headers: map[string]string{
			"Content-Type": "application/json",
		},
		Body: string(resBody),
	}, nil
}

================
File: internal/handlers/preview_file.go
================
package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"log"

	"github.com/aws/aws-lambda-go/events"
	"github.com/johnnynu/agreatchaos/api/internal/db"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

func PreviewFile(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
    log.Printf("Received request: %+v", request)
    log.Printf("Context: %+v", ctx)
    log.Printf("Path parameters: %+v", request.PathParameters)
    log.Printf("Query string parameters: %+v", request.QueryStringParameters)
    log.Printf("Headers: %+v", request.Headers)

    fileID, ok := request.PathParameters["fileId"]
    if !ok || fileID == "" {
        log.Printf("FileID not found in path parameters")
        return utils.ResponseError(fmt.Errorf("fileID is required"))
    }
    log.Printf("FileID: %s", fileID)

    // get file details
    file, err := db.GetFile(ctx, fileID)
    if err != nil {
        log.Printf("Error getting file: %v", err)
        return utils.ResponseError(err)
    }

    if file == nil {
        log.Printf("File not found for ID: %s", fileID)
        return utils.ResponseError(utils.ErrNotFound)
    }

    log.Printf("File found: %+v", file)

    res, err := json.Marshal(file)
    if err != nil {
        log.Printf("Error marshalling response: %v", err)
        return utils.ResponseError(err)
    }

    log.Printf("Sending response: %s", string(res))

    return events.APIGatewayProxyResponse{
        StatusCode: 200,
        Headers: map[string]string{
            "Content-Type": "application/json",
        },
        Body: string(res),
    }, nil
}

================
File: internal/handlers/process_upload.go
================
package handlers

import (
	"context"
	"log"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/johnnynu/agreatchaos/api/internal/db"
)

func ProcessUpload(ctx context.Context, s3Event events.S3Event) error {
    for _, record := range s3Event.Records {
        key := record.S3.Object.Key // fileID
        size := record.S3.Object.Size

        // Fetch file metadata
        file, err := db.GetFile(ctx, key)
        if err != nil {
            log.Printf("Error fetching file metadata: %v", err)
            return err
        }

        // Update file metadata
        file.FileSize = size
		file.UpdatedAt = time.Now().Format(time.RFC3339)

        err = db.UpdateFile(ctx, *file)
        if err != nil {
            log.Printf("Error updating file metadata: %v", err)
            return err
        }

        log.Printf("Successfully processed upload for file: %s", key)
    }

    return nil
}

================
File: internal/handlers/signin_user.go
================
package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider"
	"github.com/johnnynu/agreatchaos/api/internal/db"
)

func SigninUser(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	log.Printf("TESTReceived request headers: %v+", request.Headers)
	log.Println()

	// Extract cognito token from request
	authHeader := request.Headers["authorization"]
	log.Printf("TEST AUTH HEADER: %s", authHeader)
	log.Println()
	if authHeader == "" {
		log.Println("No auth token provided")
		return events.APIGatewayProxyResponse{StatusCode: 401, Body: "No token provided"}, nil
	}

	log.Printf("Token received: %s...", authHeader[:10])

	token := strings.TrimPrefix(authHeader, "Bearer ")
	if token == "" {
        log.Println("Empty token after removing Bearer prefix")
        return events.APIGatewayProxyResponse{StatusCode: 401, Body: "Invalid token format"}, nil
    }

	log.Printf("Token received (first 20 chars): %s...", token[:20])

	// verify cognito token
	claims, err := verifyToken(ctx, token)
	if err != nil {
		log.Printf("Token verification failed: %v", err)
		return events.APIGatewayProxyResponse{StatusCode: 401}, err
	}

	// extract user info from claims
	uid, ok := claims["sub"].(string)
	if !ok {
		log.Println("Unable to extract user ID from token claims")
		return events.APIGatewayProxyResponse{StatusCode: 400, Body: "Invalid token content"}, nil
	}
	email, _ := claims["email"].(string)

	log.Printf("Extracted user info - UID: %s, Email: %s", uid, email)

	// process any additional metadata from request body

	// Check if user already exists in db
	existingUser, err := db.GetUser(ctx, uid)
	if err != nil {
		log.Printf("Error checking existing user: %v", err)
		return events.APIGatewayProxyResponse{StatusCode: 500, Body: "Internal server error"}, err
	}

	isNewUser := existingUser == nil

	if isNewUser {
		user := db.User{
			UID:    uid,
			Email:     email,
			CreatedAt: time.Now().Format(time.RFC3339),
		}

		// Call CreateUser function
		err = db.CreateUser(ctx, user)
		if err != nil {
			log.Printf("Error creating new user: %v", err)
			return events.APIGatewayProxyResponse{StatusCode: 500, Body: "Failed to create new user"}, err
		}
		log.Println("New user created successfully")
	} else {
		log.Println("Existing user signed in")
	}

	res := struct {
		Message   string `json:"message"`
		IsNewUser bool   `json:"isNewUser"`
	}{
		Message:   "Sign-in successful",
		IsNewUser: isNewUser,
	}

	resBody, err := json.Marshal(res)
	if err != nil {
		log.Printf("Error creating response: %v", err)
		return events.APIGatewayProxyResponse{StatusCode: 500, Body: "Error creating response"}, nil
	}

	log.Println("Signin process completed successfully")
	return events.APIGatewayProxyResponse{
		StatusCode: 200,
		Body:       string(resBody),
		Headers: map[string]string{
			"Content-Type": "application/json",
		},
	}, nil
}

func verifyToken(ctx context.Context, token string) (map[string]interface{}, error) {
	cfg, err := config.LoadDefaultConfig(ctx)
	if err != nil {
		return nil, fmt.Errorf("unable to load SDK config, %v", err)
	}

	cognitoClient := cognitoidentityprovider.NewFromConfig(cfg)

	if token == "" {
		return nil, fmt.Errorf("empty token")
	}

	input := &cognitoidentityprovider.GetUserInput{
		AccessToken: aws.String(token),
	}

	result, err := cognitoClient.GetUser(ctx, input)
	if err != nil {
		return nil, fmt.Errorf("error verifying token, %v", err)
	}

	claims := make(map[string]interface{})
	for _, attr := range result.UserAttributes {
		claims[*attr.Name] = *attr.Value
	}

	log.Println("Token verified successfully")
	return claims, nil
}

================
File: cmd/lambda/create_file/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.CreateFile)
}

================
File: cmd/lambda/delete_file/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.DeleteFile)
}

================
File: cmd/lambda/generate_upload_url/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.GenerateUploadURL)
}

================
File: cmd/lambda/handle_upload/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.ProcessUpload)
}

================
File: cmd/lambda/list_files/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.ListFiles)
}

================
File: cmd/lambda/generate_download_url/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.GenerateDownloadURL)
}

================
File: cmd/lambda/preview_file/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {

	lambda.Start(handlers.PreviewFile)
}

================
File: cmd/lambda/signin_user/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.SigninUser)
}

================
File: cmd/lambda/stream/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.HandleStream)
}

================
File: internal/db/dynamodb.go
================
package db

import (
	"context"
	"fmt"
	"log"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

var dbClient *dynamodb.Client

func init() {
	cfg, err := config.LoadDefaultConfig(context.TODO())
	if err != nil {
		log.Fatalf("Unable to load SDK config, %v", err)
	}

	dbClient = dynamodb.NewFromConfig(cfg)
}

type User struct {
	UID    string `dynamodbav:"uid"`
	Username  string `dynamodbav:"username"`
	Email     string `dynamodbav:"email"`
	CreatedAt string `dynamodbav:"created_at"`
}

type File struct {
	FileID    string `dynamodbav:"FileID"`
	UserID    string `dynamodbav:"UserID"`
	FileName  string `dynamodbav:"FileName"`
	FileSize  int64  `dynamodbav:"FileSize"`
	FileType  string `dynamodbav:"FileType"`
	CreatedAt string `dynamodbav:"CreatedAt"`
	UpdatedAt string `dynamodbav:"UpdatedAt"`
}

func CreateUser(ctx context.Context, user User) error {
	item, err := attributevalue.MarshalMap(user)
	if err != nil {
		return fmt.Errorf("failed to marshal user: %v", err)
	}

	_, err = dbClient.PutItem(ctx, &dynamodb.PutItemInput{
		TableName: aws.String("users"),
		Item: item,
	})

	if err != nil {
		return fmt.Errorf("failed to create user in DynamoDB: %v", err)
	}

	return nil
}

func GetUser(ctx context.Context, uid string) (*User, error) {
	res, err := dbClient.GetItem(ctx, &dynamodb.GetItemInput{
		TableName: aws.String(("users")),
		Key: map[string]types.AttributeValue {
			"uid": &types.AttributeValueMemberS{Value: uid},
		},
	})

	if err != nil {
		return nil, err
	}

	if res.Item == nil {
		return nil, nil
	}

	var user User
	err = attributevalue.UnmarshalMap(res.Item, &user)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

func CreateFile(ctx context.Context, file File) error {
	item, err := attributevalue.MarshalMap(file)
	if err != nil {
		return fmt.Errorf("failed to marshal file: %v", err)
	}

	// Log the marshalled item
	log.Printf("Marshalled item: %+v", item)

	_, err = dbClient.PutItem(ctx, &dynamodb.PutItemInput{
		TableName: aws.String("FileMetadata"), // Make sure this matches your actual table name
		Item:      item,
	})

	if err != nil {
		return fmt.Errorf("failed to create file in DynamoDB: %v", err)
	}

	return nil
}

func GetFile(ctx context.Context, fileID string) (*File, error) {
	res, err := dbClient.GetItem(ctx, &dynamodb.GetItemInput{
		TableName: aws.String("FileMetadata"),
		Key: map[string]types.AttributeValue{
			"FileID": &types.AttributeValueMemberS{Value: fileID},
		},
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get file: %v", err)
	}

	if res.Item == nil {
		return nil, nil
	}

	var file File
	err = attributevalue.UnmarshalMap(res.Item, &file)
	if err != nil {
		return nil, err
	}

	return &file, nil
}

func ListUserFiles(ctx context.Context, userID string) ([]File, error) {
	input := &dynamodb.QueryInput{
		TableName: aws.String("FileMetadata"),
		IndexName: aws.String("UserID-index"),
		KeyConditionExpression: aws.String("UserID = :uid"),
		ExpressionAttributeValues: map[string]types.AttributeValue{
			":uid": &types.AttributeValueMemberS{Value: userID},
		},
	}

	res, err := dbClient.Query(ctx, input)
	if err != nil {
		return nil, fmt.Errorf("failed to query user files: %v", err)
	}

	var files []File
	err = attributevalue.UnmarshalListOfMaps(res.Items, &files)
	if err != nil {
		return nil, fmt.Errorf("failed the unmarshal files: %v", err)
	}

	return files, nil
}

func UpdateFile(ctx context.Context, file File) error {
	update := expression.Set(expression.Name("FileSize"), expression.Value(file.FileSize)).
		Set(expression.Name("FileType"), expression.Value(file.FileType)).
		Set(expression.Name("UpdatedAt"), expression.Value(file.UpdatedAt))

	expr, err := expression.NewBuilder().WithUpdate(update).Build()
	if err != nil {
		log.Printf("couldnt build expression for update: %v\n", err)
		return err
	}

	_, err = dbClient.UpdateItem(ctx, &dynamodb.UpdateItemInput{
		TableName: aws.String("FileMetadata"),
		Key: map[string]types.AttributeValue{
			"FileID": &types.AttributeValueMemberS{Value: file.FileID},
		},
		ExpressionAttributeNames: expr.Names(),
		ExpressionAttributeValues: expr.Values(),
		UpdateExpression: expr.Update(),
		ReturnValues: types.ReturnValueUpdatedNew,
	})

	if err != nil {
		log.Printf("couldnt update file %v: %v", file.FileID, err)
		return err
	}

	log.Printf("successfully updated file metadata for fileID: %s", file.FileID)
	return nil
}

func DeleteFile(ctx context.Context, fileID string, userID string) error {
	file, err := GetFile(ctx, fileID)
	if err != nil {
		return fmt.Errorf("failed to get file: %v", err)
	}
	if file == nil {
		return fmt.Errorf("file not found")
	}

	if file.UserID != userID {
		return fmt.Errorf("unauthorized: file does not belong to the user")
	}

	_, err = dbClient.DeleteItem(ctx, &dynamodb.DeleteItemInput{
		TableName: aws.String("FileMetadata"),
		Key: map[string]types.AttributeValue{
			"FileID": &types.AttributeValueMemberS{Value: fileID},
		},
	})

	if err != nil {
		return fmt.Errorf("failed to delete file: %v", err)
	}

	return nil
}

================
File: internal/handlers/complete_upload.go
================
package handlers

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"github.com/aws/aws-sdk-go-v2/service/s3/types"
	"github.com/johnnynu/agreatchaos/api/internal/db"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

type CompleteUploadRequest struct {
	FileID   string `json:"fileID"`
	UploadID string `json:"uploadId"`
	Parts    []Part `json:"parts"`
}

type Part struct {
	ETag       string `json:"ETag"`
	PartNumber int32  `json:"PartNumber"`
}

func CompleteUpload(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	log.Println("CompleteUpload function started")

	var req CompleteUploadRequest
	err := json.Unmarshal([]byte(request.Body), &req)
	if err != nil {
		log.Printf("error unmarshalling request body: %v", err)
		return utils.ResponseError(errors.New("invalid request body"))
	}

	if req.FileID == "" || req.UploadID == "" || len(req.Parts) == 0 {
		log.Println("fileID, uploadID, and/or parts are required")
		return utils.ResponseError(errors.New("fileID, uploadID, and/or parts are required"))
	}

	// Extract user ID from JWT claims
	var userID string
	if jwt, ok := request.RequestContext.Authorizer["jwt"].(map[string]interface{}); ok {
		if claims, ok := jwt["claims"].(map[string]interface{}); ok {
			if sub, ok := claims["sub"].(string); ok {
				userID = sub
			}
		}
	}

	if userID == "" {
		log.Println("Unable to extract user ID from JWT claims")
		return utils.ResponseError(fmt.Errorf("unable to extract user ID from JWT claims"))
	}

	// verify file ownership and get file metadata
	file, err := db.GetFile(ctx, req.FileID)
	if err != nil {
		log.Printf("error fetching file metadata: %v", err)
		return utils.ResponseError(err)
	}

	if file == nil {
		log.Printf("file not found: %s", req.FileID)
		return utils.ResponseError(errors.New("file not found"))
	}

	if file.UserID != userID {
		log.Printf("user %s does not own file %s", userID, req.FileID)
	}

	// set up s3 client
	cfg, err := config.LoadDefaultConfig(ctx)
	if err != nil {
		return utils.ResponseError(err)
	}

	s3Client := s3.NewFromConfig(cfg)

	// Prepare completed parts for s3 api
	completedParts := make([]types.CompletedPart, len(req.Parts))
	for i, part := range req.Parts {
		completedParts[i] = types.CompletedPart{
			ETag: aws.String(part.ETag),
			PartNumber: aws.Int32(part.PartNumber),
		}
	}

	// call CompleteMultipartUpload
	_, err = s3Client.CompleteMultipartUpload(ctx, &s3.CompleteMultipartUploadInput{
		Bucket: aws.String("chaosfiles-filestorage"),
		Key: aws.String(req.FileID),
		UploadId: aws.String(req.UploadID),
		MultipartUpload: &types.CompletedMultipartUpload{
			Parts: completedParts,
		},
	})

	if err != nil {
		log.Printf("error completing multipart upload: %v", err)
		return utils.ResponseError(err)
	}

	// update file status in the database
	file.UpdatedAt = time.Now().Format(time.RFC3339)
	err = db.UpdateFile(ctx, *file)
	if err != nil {
		log.Printf("error updating file metadata: %v", err)
		return utils.ResponseError(err)
	}

	log.Printf("multipart upload completed successfully for file: %s", req.FileID)

	return utils.ResponseOK(map[string]string{
		"message": "Upload completed successfully",
		"fileID":  req.FileID,
	})
}

================
File: internal/handlers/create_file.go
================
package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/google/uuid"
	"github.com/johnnynu/agreatchaos/api/internal/db"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

func CreateFile(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
    log.Printf("Received request: %+v", request)

    var input struct {
        FileName string `json:"file_name"`
        FileSize int64  `json:"file_size"`
        FileType string `json:"file_type"`
    }

    err := json.Unmarshal([]byte(request.Body), &input)
    if err != nil {
        log.Printf("Error unmarshalling request body: %v", err)
        return utils.ResponseError(err)
    }

    // Extract userID from JWT claims
    var userID string
	if jwt, ok := request.RequestContext.Authorizer["jwt"].(map[string]interface{}); ok {
		if claims, ok := jwt["claims"].(map[string]interface{}); ok {
			log.Printf("claims: %v", claims)
			if sub, ok := claims["sub"].(string); ok {
				log.Printf("sub: %v", sub)
				userID = sub
			}
		}
	}

    if userID == "" {
        log.Println("Unable to extract user ID from JWT claims")
        return utils.ResponseError(fmt.Errorf("unable to extract user ID from JWT claims"))
    }

    file := db.File{
        FileID:    uuid.New().String(),
        UserID:    userID,
        FileName:  input.FileName,
        FileSize:  input.FileSize,
        FileType:  input.FileType,
        CreatedAt: time.Now().Format(time.RFC3339),
        UpdatedAt: time.Now().Format(time.RFC3339),
    }

    log.Printf("Attempting to create file: %+v", file)

    err = db.CreateFile(ctx, file)
    if err != nil {
        log.Printf("Error creating file: %v", err)
        return utils.ResponseError(err)
    }

    return utils.ResponseOK(file)
}

================
File: internal/handlers/dbstream.go
================
package handlers

import (
	"context"
	"fmt"
	"log"

	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	"github.com/johnnynu/agreatchaos/api/internal/db"
)

func HandleStream(ctx context.Context, e events.DynamoDBEvent) error {
	for _, record := range e.Records {
		if record.EventName == "INSERT" || record.EventName == "MODIFY" {
			convertedImage, err := convertDDBStreamImage(record.Change.NewImage)
			if err != nil {
				log.Printf("Error converting DynamoDB stream image: %v", err)
				continue
			}

			var file db.File
			err = attributevalue.UnmarshalMap(convertedImage, &file)
			if err != nil {
				log.Printf("Error unmarshalling DynamoDB event: %v", err)
				continue
			}

			fmt.Printf("File updated: %s\n", file.FileName)
			// Here you can implement real-time notifications or trigger other processes
		} else if record.EventName == "REMOVE" {
			convertedImage, err := convertDDBStreamImage(record.Change.OldImage)
			if err != nil {
				log.Printf("Error converting DynamoDB stream image: %v", err)
				continue
			}

			var file db.File
			err = attributevalue.UnmarshalMap(convertedImage, &file)
			if err != nil {
				log.Printf("Error unmarshalling DynamoDB event: %v", err)
				continue
			}

			fmt.Printf("File deleted: %s\n", file.FileName)
			// Here you can implement cleanup processes or notifications
		}
	}

	return nil
}

func convertDDBStreamImage(image map[string]events.DynamoDBAttributeValue) (map[string]types.AttributeValue, error) {
	converted := make(map[string]types.AttributeValue)

	for k, v := range image {
		switch v.DataType() {
		case events.DataTypeString:
			converted[k] = &types.AttributeValueMemberS{Value: v.String()}
		case events.DataTypeNumber:
			converted[k] = &types.AttributeValueMemberN{Value: v.Number()}
		case events.DataTypeBinary:
			converted[k] = &types.AttributeValueMemberB{Value: v.Binary()}
		case events.DataTypeBoolean:
			converted[k] = &types.AttributeValueMemberBOOL{Value: v.Boolean()}
		case events.DataTypeNull:
			converted[k] = &types.AttributeValueMemberNULL{Value: v.IsNull()}
		case events.DataTypeList:
			listValues, err := convertDDBStreamList(v.List())
			if err != nil {
				return nil, err
			}
			converted[k] = &types.AttributeValueMemberL{Value: listValues}
		case events.DataTypeMap:
			mapValues, err := convertDDBStreamImage(v.Map())
			if err != nil {
				return nil, err
			}
			converted[k] = &types.AttributeValueMemberM{Value: mapValues}
		case events.DataTypeStringSet:
			converted[k] = &types.AttributeValueMemberSS{Value: v.StringSet()}
		case events.DataTypeNumberSet:
			converted[k] = &types.AttributeValueMemberNS{Value: v.NumberSet()}
		case events.DataTypeBinarySet:
			converted[k] = &types.AttributeValueMemberBS{Value: v.BinarySet()}
		default:
			return nil, fmt.Errorf("unsupported data type: %v", v.DataType())
		}
	}

	return converted, nil
}

func convertDDBStreamList(list []events.DynamoDBAttributeValue) ([]types.AttributeValue, error) {
	converted := make([]types.AttributeValue, len(list))

	for i, v := range list {
		switch v.DataType() {
		case events.DataTypeString:
			converted[i] = &types.AttributeValueMemberS{Value: v.String()}
		case events.DataTypeNumber:
			converted[i] = &types.AttributeValueMemberN{Value: v.Number()}
		case events.DataTypeBinary:
			converted[i] = &types.AttributeValueMemberB{Value: v.Binary()}
		case events.DataTypeBoolean:
			converted[i] = &types.AttributeValueMemberBOOL{Value: v.Boolean()}
		case events.DataTypeNull:
			converted[i] = &types.AttributeValueMemberNULL{Value: v.IsNull()}
		case events.DataTypeList:
			listValues, err := convertDDBStreamList(v.List())
			if err != nil {
				return nil, err
			}
			converted[i] = &types.AttributeValueMemberL{Value: listValues}
		case events.DataTypeMap:
			mapValues, err := convertDDBStreamImage(v.Map())
			if err != nil {
				return nil, err
			}
			converted[i] = &types.AttributeValueMemberM{Value: mapValues}
		case events.DataTypeStringSet:
			converted[i] = &types.AttributeValueMemberSS{Value: v.StringSet()}
		case events.DataTypeNumberSet:
			converted[i] = &types.AttributeValueMemberNS{Value: v.NumberSet()}
		case events.DataTypeBinarySet:
			converted[i] = &types.AttributeValueMemberBS{Value: v.BinarySet()}
		default:
			return nil, fmt.Errorf("unsupported data type: %v", v.DataType())
		}
	}

	return converted, nil
}

================
File: internal/handlers/delete_file.go
================
package handlers

import (
	"context"
	"fmt"
	"log"

	"github.com/aws/aws-lambda-go/events"
	"github.com/johnnynu/agreatchaos/api/internal/db"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

func DeleteFile(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	log.Printf("Received request: %+v", request)

	fileID, ok := request.PathParameters["fileId"]
	if !ok || fileID == "" {
		log.Println("FileID not found in path parameters")
		return utils.ResponseError(fmt.Errorf("fileID is required"))
	}
	log.Printf("FileID to delete: %s", fileID)

    // Extract userID from JWT claims
    var userID string
	if jwt, ok := request.RequestContext.Authorizer["jwt"].(map[string]interface{}); ok {
		if claims, ok := jwt["claims"].(map[string]interface{}); ok {
			log.Printf("claims: %v", claims)
			if sub, ok := claims["sub"].(string); ok {
				log.Printf("sub: %v", sub)
				userID = sub
			}
		}
	}

	if userID == "" {
        log.Println("Unable to extract user ID from JWT claims")
        return utils.ResponseError(fmt.Errorf("unable to extract user ID from JWT claims"))
    }

	if userID == "" {
        log.Println("Unable to extract user ID from JWT claims")
        return utils.ResponseError(fmt.Errorf("unable to extract user ID from JWT claims"))
    }

	err := db.DeleteFile(ctx, fileID, userID)
	if err != nil {
		log.Printf("Error deleting file: %v", err)
		return utils.ResponseError(err)
	}

	log.Printf("File %s deleted successfully", fileID)

	return events.APIGatewayProxyResponse{
		StatusCode: 200,
		Body: fmt.Sprintf("File %s deleted successfully", fileID),
	}, nil
}

================
File: internal/handlers/generate_download_url.go
================
package handlers

import (
	"context"
	"errors"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"github.com/johnnynu/agreatchaos/api/internal/db"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

func GenerateDownloadURL(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	fileID := request.QueryStringParameters["fileID"]
	if fileID == "" {
		return utils.ResponseError(errors.New("fileID is required"))
	}

	file, err := db.GetFile(ctx, fileID)
	if err != nil {
		return utils.ResponseError(err)
	}
	if file == nil {
		return utils.ResponseError(errors.New("file not found"))
	}

	cfg, err := config.LoadDefaultConfig(ctx)
	if err != nil {
		return utils.ResponseError(err)
	}

	s3Client := s3.NewFromConfig(cfg)

	// Generate pre signed url
	presignClient := s3.NewPresignClient(s3Client)
	presignedUrl, err := presignClient.PresignGetObject(ctx, &s3.GetObjectInput{
		Bucket: aws.String("chaosfiles-filestorage"),
		Key: aws.String(fileID),
		ResponseContentType: aws.String(file.FileType),
	}, s3.WithPresignExpires(time.Minute * 15))

	if err != nil {
		return utils.ResponseError(err)
	}

	// Return the presigned url
	return utils.ResponseOK(map[string]string{
		"downloadUrl": presignedUrl.URL,
		"fileName": file.FileName,
		"contentType": file.FileType,
	})
}

================
File: internal/handlers/generate_upload_url.go
================
package handlers

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"math"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"github.com/google/uuid"
	"github.com/johnnynu/agreatchaos/api/internal/db"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

const (
	maxFileSize = 1 * 1024 * 1024 * 1024 * 1024 // 1TB
	maxParts    = 10000
	multipartThreshold = 100 * 1024 * 1024 // 100MB
)

type UploadURLRequest struct {
    FileName  string `json:"fileName"`
    FileType  string `json:"fileType"`
    FileSize  int64  `json:"fileSize"`
    ChunkSize int64  `json:"chunkSize"`
}

func GenerateUploadURL(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	log.Println("GenerateUploadURL function started")

	cfg, err := config.LoadDefaultConfig(ctx)
	if err != nil {
		return utils.ResponseError(err)
	}

	s3Client := s3.NewFromConfig(cfg)
	presignClient := s3.NewPresignClient(s3Client)

	var  req UploadURLRequest
	err = json.Unmarshal([]byte(request.Body), &req)
	if err != nil {
		log.Printf("Error unmarshalling request body: %v", err)
		return utils.ResponseError(errors.New("invalid request body"))
	}

	if req.FileName == "" {
		log.Println("fileName is required")
		return utils.ResponseError(errors.New("fileName is required"))
	}

	if req.FileName == "" || req.FileSize == 0 {
		log.Println("fileName and fileSize are required")
		return utils.ResponseError(errors.New("fileName and fileSize are required"))
	}

	var userID string
	if jwt, ok := request.RequestContext.Authorizer["jwt"].(map[string]interface{}); ok {
		if claims, ok := jwt["claims"].(map[string]interface{}); ok {
			log.Printf("claims: %v", claims)
			if sub, ok := claims["sub"].(string); ok {
				log.Printf("sub: %v", sub)
				userID = sub
			}
		}
	}

    if userID == "" {
        log.Println("Unable to extract user ID from JWT claims")
        return utils.ResponseError(fmt.Errorf("unable to extract user ID from JWT claims"))
    }

	fileID := uuid.New().String()

    file := db.File{
        FileID:    fileID,
        UserID:    userID,
        FileName:  req.FileName,
		FileType: req.FileType,
		FileSize: req.FileSize,
        CreatedAt: time.Now().Format(time.RFC3339),
        UpdatedAt: time.Now().Format(time.RFC3339),
    }

    log.Printf("Attempting to create file: %+v", file)

    err = db.CreateFile(ctx, file)
    if err != nil {
        log.Printf("Error creating file: %v", err)
        return utils.ResponseError(err)
    }

	if req.FileSize < multipartThreshold {
	// Handle single part upload
	// Generate pre signed url
	presignClient := s3.NewPresignClient(s3Client)
	presignedUrl, err := presignClient.PresignPutObject(ctx, &s3.PutObjectInput{
		Bucket: aws.String("chaosfiles-filestorage"),
		Key: aws.String(fileID),
		ContentType: aws.String(req.FileType),
	}, s3.WithPresignExpires(time.Minute * 15))

	if err != nil {
		return utils.ResponseError(err)
	}

    response := struct {
        UploadURL string `json:"uploadUrl"`
        FileID    string `json:"fileID"`
    }{
        UploadURL: presignedUrl.URL,
        FileID:    fileID,
    }

	// Return the presigned url
	return utils.ResponseOK(response)
	} else {
		// handle multipart upload
		if req.ChunkSize == 0 {
			log.Println("chunkSize is required for multipart uploads")
			return utils.ResponseError(errors.New("chunkSize is required for multipart uploads"))
		}

		numParts := int(math.Ceil(float64(req.FileSize) / float64(req.ChunkSize)))
		if numParts > maxParts {
			log.Printf("Number of parts %d exceeds maximum allowed parts %d", numParts, maxParts)
			return utils.ResponseError(errors.New("file size results in too many parts"))
		}

		// initiate multipart upload
		createResp, err := s3Client.CreateMultipartUpload(ctx, &s3.CreateMultipartUploadInput{
			Bucket: aws.String("chaosfiles-filestorage"),
			Key: aws.String(fileID),
			ContentType: aws.String(req.FileType),
		})
		if err != nil {
			log.Printf("Error creating multipart upload: %v", err)
			return utils.ResponseError(err)
		}

		uploadID := *createResp.UploadId

		// Generate pre-signed URLs for each part
		partUrls := make([]string, numParts)
		for i := 0; i < numParts; i++ {
			partNumber := int32(i + 1)
			presignedReq, err := presignClient.PresignUploadPart(ctx, &s3.UploadPartInput{
				Bucket: aws.String("chaosfiles-filestorage"),
				Key: aws.String(fileID),
				UploadId: aws.String(uploadID),
				PartNumber: &partNumber,
			}, s3.WithPresignExpires(time.Hour*24))

			if err != nil {
				log.Printf("Error generating pre-signed URL for part %d: %v", partNumber, err)
				return utils.ResponseError(err)
			}

			partUrls[i] = presignedReq.URL
		}

		response := struct {
			UploadID string   `json:"uploadId"`
			FileID   string   `json:"fileID"`
			PartUrls []string `json:"partUrls"`
		}{
			UploadID: uploadID,
			FileID:   fileID,
			PartUrls: partUrls,
		}

		return utils.ResponseOK(response)
	}
}

================
File: internal/handlers/list_files.go
================
package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"log"

	"github.com/aws/aws-lambda-go/events"
	"github.com/johnnynu/agreatchaos/api/internal/db"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

func ListFiles(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	log.Printf("Received request: %+v: ", request)

    // Extract userID from JWT claims
    var userID string
	if jwt, ok := request.RequestContext.Authorizer["jwt"].(map[string]interface{}); ok {
		if claims, ok := jwt["claims"].(map[string]interface{}); ok {
			log.Printf("claims: %v", claims)
			if sub, ok := claims["sub"].(string); ok {
				log.Printf("sub: %v", sub)
				userID = sub
			}
		}
	}

	if userID == "" {
        log.Println("Unable to extract user ID from JWT claims")
        return utils.ResponseError(fmt.Errorf("unable to extract user ID from JWT claims"))
    }

	files, err := db.ListUserFiles(ctx, userID)
	if err != nil {
		log.Printf("Error listing files: %v", err)
		return utils.ResponseError(err)
	}

	// Convert files to JSON
	resBody, err := json.Marshal(files)
	if err != nil {
		log.Printf("Error marshalling response: %v", err)
		return utils.ResponseError(err)
	}

	return events.APIGatewayProxyResponse{
		StatusCode: 200,
		Headers: map[string]string{
			"Content-Type": "application/json",
		},
		Body: string(resBody),
	}, nil
}

================
File: internal/handlers/preview_file.go
================
package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"log"

	"github.com/aws/aws-lambda-go/events"
	"github.com/johnnynu/agreatchaos/api/internal/db"
	"github.com/johnnynu/agreatchaos/api/pkg/utils"
)

func PreviewFile(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
    log.Printf("Received request: %+v", request)
    log.Printf("Context: %+v", ctx)
    log.Printf("Path parameters: %+v", request.PathParameters)
    log.Printf("Query string parameters: %+v", request.QueryStringParameters)
    log.Printf("Headers: %+v", request.Headers)

    fileID, ok := request.PathParameters["fileId"]
    if !ok || fileID == "" {
        log.Printf("FileID not found in path parameters")
        return utils.ResponseError(fmt.Errorf("fileID is required"))
    }
    log.Printf("FileID: %s", fileID)

    // get file details
    file, err := db.GetFile(ctx, fileID)
    if err != nil {
        log.Printf("Error getting file: %v", err)
        return utils.ResponseError(err)
    }

    if file == nil {
        log.Printf("File not found for ID: %s", fileID)
        return utils.ResponseError(utils.ErrNotFound)
    }

    log.Printf("File found: %+v", file)

    res, err := json.Marshal(file)
    if err != nil {
        log.Printf("Error marshalling response: %v", err)
        return utils.ResponseError(err)
    }

    log.Printf("Sending response: %s", string(res))

    return events.APIGatewayProxyResponse{
        StatusCode: 200,
        Headers: map[string]string{
            "Content-Type": "application/json",
        },
        Body: string(res),
    }, nil
}

================
File: internal/handlers/process_upload.go
================
package handlers

import (
	"context"
	"log"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/johnnynu/agreatchaos/api/internal/db"
)

func ProcessUpload(ctx context.Context, s3Event events.S3Event) error {
    for _, record := range s3Event.Records {
        key := record.S3.Object.Key // fileID
        size := record.S3.Object.Size

        // Fetch file metadata
        file, err := db.GetFile(ctx, key)
        if err != nil {
            log.Printf("Error fetching file metadata: %v", err)
            return err
        }

        // Update file metadata
        file.FileSize = size
		file.UpdatedAt = time.Now().Format(time.RFC3339)

        err = db.UpdateFile(ctx, *file)
        if err != nil {
            log.Printf("Error updating file metadata: %v", err)
            return err
        }

        log.Printf("Successfully processed upload for file: %s", key)
    }

    return nil
}

================
File: internal/handlers/signin_user.go
================
package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/cognitoidentityprovider"
	"github.com/johnnynu/agreatchaos/api/internal/db"
)

func SigninUser(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	log.Printf("TESTReceived request headers: %v+", request.Headers)
	log.Println()

	// Extract cognito token from request
	authHeader := request.Headers["authorization"]
	log.Printf("TEST AUTH HEADER: %s", authHeader)
	log.Println()
	if authHeader == "" {
		log.Println("No auth token provided")
		return events.APIGatewayProxyResponse{StatusCode: 401, Body: "No token provided"}, nil
	}

	log.Printf("Token received: %s...", authHeader[:10])

	token := strings.TrimPrefix(authHeader, "Bearer ")
	if token == "" {
        log.Println("Empty token after removing Bearer prefix")
        return events.APIGatewayProxyResponse{StatusCode: 401, Body: "Invalid token format"}, nil
    }

	log.Printf("Token received (first 20 chars): %s...", token[:20])

	// verify cognito token
	claims, err := verifyToken(ctx, token)
	if err != nil {
		log.Printf("Token verification failed: %v", err)
		return events.APIGatewayProxyResponse{StatusCode: 401}, err
	}

	// extract user info from claims
	uid, ok := claims["sub"].(string)
	if !ok {
		log.Println("Unable to extract user ID from token claims")
		return events.APIGatewayProxyResponse{StatusCode: 400, Body: "Invalid token content"}, nil
	}
	email, _ := claims["email"].(string)

	log.Printf("Extracted user info - UID: %s, Email: %s", uid, email)

	// process any additional metadata from request body

	// Check if user already exists in db
	existingUser, err := db.GetUser(ctx, uid)
	if err != nil {
		log.Printf("Error checking existing user: %v", err)
		return events.APIGatewayProxyResponse{StatusCode: 500, Body: "Internal server error"}, err
	}

	isNewUser := existingUser == nil

	if isNewUser {
		user := db.User{
			UID:    uid,
			Email:     email,
			CreatedAt: time.Now().Format(time.RFC3339),
		}

		// Call CreateUser function
		err = db.CreateUser(ctx, user)
		if err != nil {
			log.Printf("Error creating new user: %v", err)
			return events.APIGatewayProxyResponse{StatusCode: 500, Body: "Failed to create new user"}, err
		}
		log.Println("New user created successfully")
	} else {
		log.Println("Existing user signed in")
	}

	res := struct {
		Message   string `json:"message"`
		IsNewUser bool   `json:"isNewUser"`
	}{
		Message:   "Sign-in successful",
		IsNewUser: isNewUser,
	}

	resBody, err := json.Marshal(res)
	if err != nil {
		log.Printf("Error creating response: %v", err)
		return events.APIGatewayProxyResponse{StatusCode: 500, Body: "Error creating response"}, nil
	}

	log.Println("Signin process completed successfully")
	return events.APIGatewayProxyResponse{
		StatusCode: 200,
		Body:       string(resBody),
		Headers: map[string]string{
			"Content-Type": "application/json",
		},
	}, nil
}

func verifyToken(ctx context.Context, token string) (map[string]interface{}, error) {
	cfg, err := config.LoadDefaultConfig(ctx)
	if err != nil {
		return nil, fmt.Errorf("unable to load SDK config, %v", err)
	}

	cognitoClient := cognitoidentityprovider.NewFromConfig(cfg)

	if token == "" {
		return nil, fmt.Errorf("empty token")
	}

	input := &cognitoidentityprovider.GetUserInput{
		AccessToken: aws.String(token),
	}

	result, err := cognitoClient.GetUser(ctx, input)
	if err != nil {
		return nil, fmt.Errorf("error verifying token, %v", err)
	}

	claims := make(map[string]interface{})
	for _, attr := range result.UserAttributes {
		claims[*attr.Name] = *attr.Value
	}

	log.Println("Token verified successfully")
	return claims, nil
}

================
File: cmd/lambda/complete_upload/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.CompleteUpload)
}

================
File: pkg/utils/response.go
================
// pkg/utils/response.go
package utils

import (
	"encoding/json"
	"errors"

	"github.com/aws/aws-lambda-go/events"
)

var ErrNotFound = errors.New("resource not found")

func ResponseOK(body interface{}) (events.APIGatewayProxyResponse, error) {
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return ResponseError(err)
	}

	return events.APIGatewayProxyResponse{
		StatusCode: 200,
		Body:       string(bodyBytes),
		Headers: map[string]string{
			"Content-Type": "application/json",
		},
	}, nil
}

func ResponseError(err error) (events.APIGatewayProxyResponse, error) {
	statusCode := 500
	if errors.Is(err, ErrNotFound) {
		statusCode = 404
	}
	return events.APIGatewayProxyResponse{
		StatusCode: statusCode,
		Body:       err.Error(),
		Headers: map[string]string{
			"Content-Type": "application/json",
		},
	}, nil
}

================
File: cmd/lambda/generate_download_url/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.GenerateDownloadURL)
}

================
File: cmd/lambda/generate_upload_url/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.GenerateUploadURL)
}

================
File: cmd/lambda/delete_file/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.DeleteFile)
}

================
File: cmd/lambda/create_file/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.CreateFile)
}

================
File: cmd/lambda/handle_upload/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.ProcessUpload)
}

================
File: cmd/lambda/list_files/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.ListFiles)
}

================
File: cmd/lambda/signin_user/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.SigninUser)
}

================
File: cmd/lambda/preview_file/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {

	lambda.Start(handlers.PreviewFile)
}

================
File: cmd/lambda/stream/main.go
================
package main

import (
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/johnnynu/agreatchaos/api/internal/handlers"
)

func main() {
	lambda.Start(handlers.HandleStream)
}
